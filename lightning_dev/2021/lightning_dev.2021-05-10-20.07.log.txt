20:07:22 <ariard> #startmeeting lightning-dev
20:07:22 <lndev-bot> Meeting started Mon May 10 20:07:22 2021 UTC and is due to finish in 60 minutes.  The chair is ariard. Information about MeetBot at http://wiki.debian.org/MeetBot.
20:07:22 <lndev-bot> Useful Commands: #action #agreed #help #info #idea #link #topic #startvote.
20:07:22 <lndev-bot> The meeting name has been set to 'lightning_dev'
20:07:29 <ariard> oh works at first try
20:07:31 <rusty> I am liking "Canaux de foudre" though...
20:07:55 <ariard> #topic on-the-fly channel upgrade
20:08:18 <ariard> rusty: you've the mic to explain #869, #868!
20:08:20 <rusty> OK, I have an update draft... let me push it...
20:08:27 <t-bast> rusty: we're probably going to use that one for a feature, "canaux de foudre" looks badass
20:09:22 <rusty> t-bast: :)
20:09:40 <cdecker> Excellent choice of message names ^^
20:10:01 <rusty> OK, so I was looking at channel upgrade.  We have wanted this for a while, but I really did want it for simplified update protocol.
20:10:52 <rusty> It's easiest if you can assert that the new method/format applies canonically from a given commit number.  Turns out that fits pretty well with reconnection, where we explicitly send the numbers.
20:11:01 <roasbeef> saw that, was interesting we went w/ pretty different approaches (independent of the scope of simplified updates, not sure how much value vs effort that brings)
20:11:23 <roasbeef> the main diff is that what I've been working on in the background moves to making everything explicit w.r.t channel funding, as soon there may not be a "default/preferred" chan type
20:11:58 <rusty> roasbeef: yeah, taproot will be a big one too.
20:12:21 <roasbeef> also what I've been tinkering on is a bit more general, as it makes room to let you update things like the dust limit or the # of max HTLCs on the fly, while the channle is being used within teh same connection context
20:12:37 <rusty> roasbeef: this protocol is basically "one side proposes update, the other says what updates are OK".
20:12:39 <ariard> rusty: are you covering channel policy update, like open/accept scopes?
20:12:51 <roasbeef> been bogged down by the non-LN parts of my job, so I've had it paused for the past few weeks
20:13:16 <rusty> ariard: not sure what that means?
20:13:20 <t-bast> roasbeef: IIUC updating things like dust_limit or max_accepted_htlcs would also be easy with rusty's proposal, or am I missing something?
20:13:39 <roasbeef> t-bast: but you'd need to re-initiate the connection right?
20:13:42 <t-bast> It sounds like once we're in quiescence, we can upgrade pretty much whatever we want
20:13:46 <roasbeef> it also doesn't make things explicit
20:14:09 <roasbeef> like w/ mine, we add a chan_type to the open/accept messages, so we avoid the weird issues we ran into when we make certain feature bits required, and we had to downgrade our bits to maintain connections w/ eclair nodes, etc
20:14:12 <t-bast> oh got it, but I don't think we'd need the channel_reestablish to trigger updating channel parameters once we're in quiescence, right rusty?
20:14:43 <ariard> rusty: well things like dust_limit, htlc_min_msat
20:14:45 <rusty> t-bast:  it's far easier, since it automatically works for lost messages though.
20:14:49 <roasbeef> at a high level I've been tinkering with: new shtudown liek message to propose a commitment update, new update_fee like message to commit the proposal by one or both nodes, works w/ the existing retransmission stuff as it's just another log update
20:14:51 <cdecker> Yes, the reconnect commit is separate from the quiescence
20:15:19 <roasbeef> not following where quiescence comes in?
20:15:23 <rusty> Frankly, changing other things is far far easier with simplified commitment update.  You're *always* quiescent at the start of your turn, and the state is the same on both sides.
20:15:33 <t-bast> roasbeef: so your proposal is kind of a two-phase commit with new messages?
20:15:57 <roasbeef> t-bast: yes, w/ the initaitor doing the commit, with a fast path where if only the responder wants to change then you can do it more quickly
20:16:13 <roasbeef> it also leaves room for backing out, since only the initator commits the actual confi change
20:16:19 <roasbeef> it works kinda like the way raft does config updates
20:16:41 <roasbeef> backing out as in, I disagree w/ your fancy commitment type or w/e, so we don't need to run into like an invalid sig and destroy the channel in that case or w/e
20:16:56 <t-bast> it's true that the high-level feature we want to get (updating channel things) has a very large design space
20:17:43 <roasbeef> indeed, I had a goal to go w/ something more general, and there're a lot of hard coded params rn that you can't ever change once the chan is open, so had eyes set on a two birds w/ one stone kinda thing
20:17:48 <niftynei> where does splice fit into the list of "channel update parameters"
20:17:59 <rusty> I'm determined to pursue simplified commitment protocol, since I don't believe we will ever get all the synchronization bugs out of all the implementations :(  It's been five years and we're still finding them.  Adding more complexity is not a win.
20:18:01 <roasbeef> the propose messages are just a signed tlv (signed so the initaitor can do retransmission, etc)
20:18:01 <t-bast> rusty: simplified commitment update is the change to the channel state machine, right? Where we have turns instead of the current message flow?
20:18:21 <rusty> t-bast: kind of.  It's just a subset of the current state machine.
20:18:39 <roasbeef> if ppl implement the simplified stuff or not, again we'd need to make sure we have explicit funding, as it makes diff tradeoffs
20:18:58 <roasbeef> we fixed a recent issue on our state machine, likely the last (fingers crossed lol)?
20:19:05 * BlueMatt admits he likes going with quiescence/turns on new changes, but is dubious of the value of doing turns for existing stuff.
20:19:22 <roasbeef> but I guess is it a bigger hill to climb to introduce something brand new or just better understand/formalize/spec the existing one
20:19:28 <BlueMatt> does anyone else have fuzzing on their state machine to catch the inconsistent-state bugs?
20:19:33 <rusty> BlueMatt: it makes splicing, and changing other channel parameters much easier.
20:19:39 <roasbeef> yeh we've been using one to find our recent issues BlueMatt
20:20:11 <roasbeef> rusty: at the cost of x-put, and also the effort to switch everything over (and the unknowns that lie there) to the new method?
20:20:41 <rusty> roasbeef: that's why I'm implementing it, so I have a concrete idea of what's involved.
20:21:12 <BlueMatt> rusty: right, we've hashed this out on the ml, I dont really think I have anything to add to that convo beyond what I'd said before - that quiescence relies on a lot of the same code as shutdown anyway, whereas simplified commitment adds new logic around queues, so I'd think the first is easier, but curious to see your implementation.
20:21:26 <roasbeef> mhmm, but then there may be a scenario where ppl add it, but don't make it the default, which motivates explicit funding (so no more feature bit implicit negotiation)
20:21:33 <rusty> BlueMatt:quiescence also needs queues :)
20:21:43 <niftynei> what is explicit funding?
20:21:58 <roasbeef> niftynei: so my open chan message just adds a new tlv that says the type of channel I'm opening
20:22:13 <roasbeef> rn we expect a certain type based on feature bits, which doesn't work when you have "non-default" commitment/funding types
20:22:22 <ariard> ah, typed funding sounds a good name
20:22:37 <BlueMatt> rusty: true, but for fewer things - I *think* it adds fewer states, but I may be wrong.
20:22:45 <roasbeef> like we had an issue when we made static key required: older nodes didn't udnerstand it, so we couldn't establish our older connections w/ say eclair nodes, and had to _downgrade_ those feature bits, then reject those funding attempts we didn't like
20:22:46 <rusty> roasbeef: yeah, I wrestled with the same. I have been calling them channel features, which is overloaded unf.  Types is beter.
20:22:55 <roasbeef> vs being able to signal what you understand, then explicitly tell the other side which one yuo're trying to use
20:23:22 <rusty> roasbeef: yeah, definitely better for diags when things go wrong, too.
20:23:31 <roasbeef> so there's another thing here about the ability to not really flip chan related featire bits to required
20:23:32 <t-bast> yep that would be quite useful
20:23:44 <roasbeef> as then you can't maintain older connections w/ those you have legacy chans w/, w/o unsetting those bits
20:24:07 <roasbeef> you're basically forced to downgrade to the lowest common known chan vs being able to keep that connection then only accepting requests to fund your preferred chans
20:24:17 <niftynei> oh i see. interesting
20:24:21 <rusty> Yes, channel bits in open/accept FTW?
20:24:30 <roasbeef> not bits, just an explicit type
20:24:31 <rusty> Though ideally upgrade will also help transition.
20:24:36 <roasbeef> since you need to pick one
20:24:52 <niftynei> picking the type scope seems... challenging
20:25:00 <rusty> roasbeef: except simplified commitment protocol is an orthogonal option unfortunately.
20:25:01 <roasbeef> niftynei: how so?
20:25:19 <roasbeef> rusty: don't follow, it's basically a new commitment type as the engine changes, no?
20:25:33 <roasbeef> so you'd need something to uprgade on the fly, then start to use that
20:25:39 <rusty> roasbeef: no, you can have that and taproot, or that and Eltoo...
20:25:46 <niftynei> what necesscitates a new type?
20:25:54 <roasbeef> mhmm that can be another dimension/field -> commitment engine or w/e
20:26:12 <roasbeef> niftynei: what if I want to use the new taproot commitment, not not this new commitment engine?
20:26:19 <niftynei> is eltoo a type? option_anchor_outputs?
20:26:24 <ariard> and another dimension field would be dlc or any other type of packets on  top of an anchor channel
20:26:35 <roasbeef> sure anything future thing really, DLC, etc, etc
20:27:01 <roasbeef> on the pool side we have a new channel type that basically forks the funding commitment, so we can have a uni-directional channel that pays out coupon payments for the lease
20:27:19 <roasbeef> a similar structure is useful for DLC stuff as well, before something like no_input
20:27:58 <ariard> what do you mean by forking the funding commitment? a new intermediate stage
20:28:02 <rusty> roasbeef: we already have a defined feature bitmap, I think we should use it?  And define that you can only have one bit (for now).
20:28:09 <roasbeef> yeh like the eltoo kick off transaction type stuff ariard
20:28:35 <roasbeef> rusty: yeh but imo I don't see how the bit map is compatible w/ explicit funding, there may be overlap, but I don't want to use that channel type as I just understand it as an example
20:28:57 <roasbeef> ariard: so funding output, then intermediate transaction w/ two outputs, then another level of the actual commitments
20:29:15 <ariard> it's just a bitmap matrix like doesn't sound to work well with all the upcoming features
20:29:18 <roasbeef> DLC rn wants something like this, as you want to be able to update the channels independently w/o invalidting the sigs w/ a txid change, w/ no_input it matters less
20:29:31 <ariard> like you might be interested to use taproot output but want to apply zero-fee on the commitment once we have package relay
20:29:35 <ariard> that kind of combinations
20:30:13 <t-bast> I think it's dangerous to support a wide number of such combinations
20:30:18 <roasbeef> yeh in my mind, you'd just flatten that all out to induvidual types
20:30:23 <roasbeef> you signal if you understand it or not in feature bits
20:30:32 <roasbeef> then at execution you explcitily say which one you're using
20:31:02 <roasbeef> commit_sig would also start to carry that, since it'll b epossible to have two commitments of diff commit types until revoked, so you get the context during retransmission/reconstruction
20:31:03 <niftynei> i'm struggling to understand the difference btw feature bits and types. it sort of sounds like you're just naming each possible feature-bit combination a 'type'?
20:31:14 <BlueMatt> t-bast: yea, you really want to say "I support sets A+B, A+B+C, but not A+C"
20:31:48 <roasbeef> niftynei: if we send over feature bits, and have 3 channel types overlapping (we just take em from the node ann for w/e), which one are we using for the funding attempt?
20:32:16 <niftynei> ok but you haven't explained what a 'channel type' is and how it's not a feature bit?
20:32:23 <ariard> roasbeef: right for DLC, idea was to group your DLC by frequency of update to avoid the really active ones bothering you update the update-once-in-a-year-contract
20:32:36 <t-bast> BlueMatt: yeah but I'd really want my implementation to avoid supporting 10 different cases, ariard's comment seemed to imply a big combinatorial explosion of possible channel configurations, and I find that dangerous (hard to properly test)
20:32:50 <roasbeef> niftynei: say anchors is type 4, static key is 3, etc, etc
20:33:08 <roasbeef> ariard: yeh that's another option, large design space, for our specific use case it's better they be fully independent
20:33:34 <roasbeef> t-bast: if there's a lot of types, you just need to know which ones you support or not, signalling happens at the feature bit level, execution one level down
20:33:42 <ariard> t-bast: well flattening as proposed by roasbeef might work, we should aslo consider we won't deploy everything on the same dev cycle, so yuou might deprecrate old types
20:33:49 <roasbeef> particularly w/ taproot, the design space really starts to expand
20:34:03 <niftynei> roasbeef, i think another way to restate what you're proposing is committing to a feature-bit set at open
20:34:06 <roasbeef> and the impls are getting more and more de-synchronized today
20:34:44 <niftynei> which maps to your 'explicit vs implicit' designation earlier
20:34:51 <ariard> yes lloyd was also working on asymmetric channnels leveraging witness scripting
20:35:36 <roasbeef> ariard: this variant? https://eprint.iacr.org/2020/476
20:35:43 <ariard> like i would say we should only converge on a standard secure/confidential type post-taproot and let folks explore the fringers
20:35:46 <ariard> *the fringes
20:36:02 <ariard> roasbeef: yep this one iirc : https://github.com/LLFourn/witness-asymmetric-channel/blob/master/original.md
20:36:22 <BlueMatt> t-bast: right, that was my point, like you could just support "all features up to A, B, or C, but not the combinatorial explosion of A, B, and C"
20:36:35 <rusty> We may get an explosion of types, but I hope we'll generally converge on a few useful best ones.
20:36:56 <BlueMatt> right, as long as you can restrict yourself to a limited set
20:37:02 <t-bast> Sounds good then ;)
20:37:03 <ariard> yep that's my thinking too, the few useful best ones will emerge
20:37:04 <BlueMatt> an all-out explosion would be really bad.
20:37:22 <BlueMatt> ie as long as we can limit ourselves to supporting only the "best sets"
20:37:46 <roasbeef> imo this is related to the discussion to move away from teh current BOLT documetn structure and move forward with more contained/standalone documents
20:38:13 <roasbeef> there's a lot of potential for innovation/experimentation, and I wouldn't really expect everyone to commit to keep up w/ it all, as everyone has diff priorities/needs
20:39:00 <ariard> and some specification is reused by other dev communities like DLC
20:39:01 <t-bast> agreed, but there are things that really need to be in the core, even for security's sake: channel commitment format is one for example
20:39:29 <ariard> t-bast: maybe need all the scope of channel commitment formats but one dynamic upgrade mechanism seems quite core imho
20:39:31 <t-bast> it's really important to have as many eyes as possible on the parts that are critical for funds safety
20:39:34 <ariard> *maybe not
20:39:42 <niftynei> i'm not sure what the network as a whole gains by a fractured approach to a common spec
20:39:48 <rusty> I like a twist on roasbeef's idea: the open msg should enumerate all the combinations it is OK with, the accept msg picks one.
20:40:59 <niftynei> (they are called 'network effects' for a reason lol)
20:41:25 <t-bast> rusty: that's similar to the closing change we've done recently: the node initiating close specifies the fees it's ok with, and the other node chooses one in that range
20:41:47 <roasbeef> niftynei: in the end, the network in a sense is the shared HTLC construct
20:41:50 <t-bast> (https://github.com/lightningnetwork/lightning-rfc/pull/847)
20:41:58 <roasbeef> as long as that's the asme along a route, doesn't really matter what transfers it
20:42:10 <niftynei> t-bast: that's still on my to-do list, btw!
20:42:12 <roasbeef> or ptlc or w/e the kid are calling it these days
20:42:16 <t-bast> but it does matter for the network as a list if it's unsecure!
20:42:24 <ariard> roasbeef: htlc-over-opendime?
20:43:03 <t-bast> let's not forget that ariard found an issue with anchor even after it had been reviewed a lot, so imagine what happens when new channel commitment types are deployed without getting as much review?
20:43:20 <ariard> rusty: i like this twist too, you guarantee to do the negotiation in one RTT
20:43:34 <niftynei> in a sense, sure. in practical reality it's confusing to end-users if nodes dont interoperate as expected lol
20:43:47 <roasbeef> t-bast: tradeoffs in the end, do you think you'd be able to keep up w/ and fully review everything that came across the board?
20:44:04 <roasbeef> from my pov feels like we've kinda reeached that point already
20:44:05 <t-bast> roasbeef: no, but I think it's a good thing that it moves slowly
20:44:10 <BlueMatt> what t-bast said. There's massive usability loss from fragmentation. its one thing to have certain major systems (like DLC) separate, but something else to have things like keysend or 0-value invoices be fragmented. those we've seen actively hurt users many times.
20:44:23 <t-bast> roasbeef: frustrating sometimes, but better in the long run imho
20:44:49 <ariard> but maybe we should have differing tracks inside the same LN specification effort
20:44:59 <roasbeef> nimbleness of LN as is is a strength imo, like rn a buncha wallets do custom things that improve their UX, they just did it and didn't need to "ask permission" from anyone as they were driving towards a precise goal
20:45:05 <ariard> the ietf is doing it for a bunch of protocols like sip
20:45:15 <cdecker> Agreed, experimentation is all good and fine, but we need a minimal common set that ensures compatibility and a good UX
20:45:17 <rusty> I sympathize with roasbeef here: more freedom to experiment is good, as long as it's explicit in the protocol.
20:45:21 <roasbeef> ideally taht custom stuff is at least _documented_, wouldn't expect everyone to impl all of it tho
20:46:06 <t-bast> of course there are parts of the protocol that are prone to quicker prototyping and deployment, but for the really core parts I think it's important to move slow and get everyone to look at it - but I'm not sure where to put the boundary of what is "core"
20:46:08 <BlueMatt> right, my issue is more "going off in one direction without even documenting it". I think we all agree experimentation is good, as long as those things make their way into the spec eventually and we can learn from the experiementation and get broader review.
20:46:19 <ariard> i agree on proning the experimentation aspect, as long as we can find a proper documentation somewhere
20:46:49 <roasbeef> another example is something like ln-url: pretty much all the major wallets implement it, but the spec itself is pretty light and isolated from everything else
20:47:20 <roasbeef> some of us may not really like the tradeoffs it makes, but wallets use it as it solves a problem for them
20:47:26 <t-bast> roasbeef: good example, this is the kind of thing that would make sense to have in a BIP-like document close to the spec
20:47:27 <rusty> roasbeef: +1
20:47:50 <niftynei> ln-url doesn't deal with inter-node communication
20:47:58 <roasbeef> t-bast: yeh def, in terms of like "tracks" agree there's like a fundamental track (htlc types, etc) then would be others
20:48:13 <roasbeef> niftynei: it kinda does, ppl use it to communicate invoices between nodes
20:48:19 <BlueMatt> ln-url is great, I also love that it has documentation and such. would be great if it were *in* the bolts repo, maybe under an experiemtntal/ directory
20:48:21 <roasbeef> for like scan to withdraw flows, etc
20:48:28 <ariard> yep we should have more tracks if people feel like it, bip do have consensus/p2p/applications/etc
20:48:49 <roasbeef> fwiw offers kinda occupies the same domain as it tho, as they offer similar functionality in the end
20:48:50 <BlueMatt> this may be somewhere we can learn from BIPs - they exist only to communicate things people wish to be interoperable, not to "get review", we could have an experimental/ folder for similar documents
20:48:55 <rusty> Well, offers covers much of this (though not all!).
20:49:11 <BlueMatt> those things dont have to go into the main bolts, but they could be a "for now we're doign this, we may do something else later"
20:49:21 <ariard> and another aspect to consider is documenting "best practices" especially how you taught node operators to select config parameters in function of use-case
20:50:21 <t-bast> BlueMatt: +1 for the "experimental" or "proposals" folder, what would be the criteria to get it merged though? What review does it need?
20:50:32 <roasbeef> I g2g in 10
20:50:33 <BlueMatt> I'd assume none
20:50:50 <BlueMatt> like there should be *opportunity* for review, but it could be, like BIPs, "author documents"
20:50:50 <ariard> t-bast: i would say a minimal bar of not being junk and decently written, like only 1 implem supporting it?
20:51:01 <BlueMatt> like, the author decides what the contents are, and others can only provide feedback
20:51:04 <t-bast> Ok, interesting
20:51:11 <rusty> Anyway, thanks for the discussion, esp roasbeef.  I am going to go back and change the upgrade proposal to explicitly list a set of allowable upgrades rather than a single bitfield (which has awkward semantics as diff possibilities arise).
20:51:24 <t-bast> And the stronger review would happen when we'd want to move it from "experimental/proposal" to a core BOLT?
20:51:34 <roasbeef> rusty: pushes me actually write down my ideas too lol
20:51:41 <ariard> t-bast: in practice review happen when you implement the stuff
20:51:43 <rusty> roasbeef: :)
20:51:52 <BlueMatt> t-bast: yes
20:52:06 <roasbeef> I think splitting thngs out would also make the spec a lot easier to read, idk about y'all but I find it hard parsing thru it rn, as there's basically a buncha if statements everywhere
20:52:06 <BlueMatt> rusty and roasbeef: thanks y'all!
20:52:13 <roasbeef> especially when reviewing diffs
20:52:22 <t-bast> roasbeef:iIt would be great to have two proposals to look at to see the differences!
20:52:26 <BlueMatt> yea, I tend to agree, though its good to have a "core thing"
20:52:27 <roasbeef> also not clear to new ppl how things have evolved over time either, other than looking at the git history ofc
20:52:30 <rusty> roasbeef: Grand Feature Elimination is on my TODO, TBH.
20:52:42 <ariard> roasbeef: yeah made the point about interactive construction protocol could be its own BIP
20:53:00 <ariard> *BOLT
20:53:05 <rusty> (After we have upgradality ofc)
20:53:10 <rusty> *upgradability
20:53:17 <ariard> okay let's move on from upgradability?
20:53:24 <rusty> ariard: please :)
20:53:30 <ariard> do we have another long-term subject we want to parse?
20:53:35 <t-bast> let's call these "sparks" instead of lightning BIPs
20:53:36 <ariard> like dual-funding?
20:53:57 <ariard> t-bast: tonnere, foudre, orage?
20:54:05 <rusty> ariard: oh, dual-funding, splicing and splice-to-close are all related, BTW.
20:54:16 <ariard> #topic dual-funding & friends
20:54:30 <t-bast> ariard: étincelle, for the experimental proposals!
20:55:10 <ariard> wr.t to dual-funding or any others multi-party funded protocols like splicing
20:55:16 <rusty> Not sure if I should leave this to niftynei...
20:55:31 <niftynei> i'm not sure what kind of discussion we're looking for haha
20:55:37 <niftynei> so go ahead rusty?
20:55:55 <rusty> Err, OK.  I'm two coffees down, so good to go I guess :)
20:55:56 <ariard> we're quite vulnerable to a bunch of dumb DoSes as documented here : https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-May/003033.html
20:56:54 <ariard> so rn, opening a multi-party funded channel require more trust in your counterparty
20:57:07 <ariard> than single-funded one, and i'm not if it's rightly captured by the spec
20:57:37 <rusty> So, the basic protocol of DF uses a negotiation method, which took more than a year to refine because we wanted to reuse it for everything else, and we wanted it to be usable by either peer to coordinate with multiple peers at once.
20:57:50 <ariard> and beyond adverserial settings, we have also lazzy/buggy peers, where you might want to fallback and funding timeout recovery style of things
20:58:19 <rusty> The good news is, it works for splice, and a to-be-defined subset of splice which is splice-to-close.
20:59:02 <rusty> Implementation-wise: niftynei has reckless experimental option which has been used on mainnet for DF (though I don't think they had to RBF?), and I'm actively working on splice.  Splice is easier to define if quiescent, hence my work there.
20:59:27 <rusty> (Close is naturally quiescent since we define it to start once all updates are done).
21:00:49 <niftynei> rusty, correct the DF open worked as expected the first time lol
21:00:51 <ariard> rusty: what flavor of splice-in it's about? you parallelize channel updates until new funding_txo has enough confirmation?
21:00:54 <niftynei> ariard, by DOS you mean "channel doesn't open (in a reasonable timeframe)"
21:01:31 <ariard> niftynei: yeap funding doesn't confirm in a reasonable timeframe, what should you do?
21:01:33 <t-bast> for splice, do you stay quiescent until you have on-chain confirmations?
21:01:41 <niftynei> which is .. currently the case with channel opens because of feerates etc. in theory we get around that by double-spending the inputs after a timeout
21:01:56 <niftynei> :s/in theory//
21:01:58 <rusty> ariard: yes, exactly.  Technically there's no splice in vs out distinction then.  Splice proposer pays for 1 input (spending channel), 1 output (new channel out) and the tx core. Other side can choose to add whatever they want.
21:02:14 <rusty> t-bast: naah, just during active negotiation.
21:02:23 <rusty> t-bast: i.e. tx construction.
21:02:31 <ariard> niftynei: it sounds good in non-adverserial settings, in non-adverserial settings you should beware upper bounding your fee-bumping
21:02:37 <ariard> *adverserial settings
21:02:38 <t-bast> how does that work if that tx never confirms?
21:02:58 <t-bast> you *have* to make it confirm through CPFP whatever the cost?
21:03:15 <niftynei> right now you have to CPFP a channel open if it doesn't confirm
21:03:19 <rusty> t-bast: you carry those forever, and you can have multiple; only constraint is that they must pay 1.25x feerate of previous.
21:03:36 <niftynei> the DF protocol provides a method for initiating an RBF with your peer
21:04:06 <t-bast> ok, it's a chain so you only move forward? Does it mean you could have two unconfirmed splices going (the second one applied after the first one)?
21:04:32 <rusty> t-bast: no, they are all in parallel.  You can't start a second on top of the first.
21:04:46 <rusty> t-bast: (we had to stop somewhere!)
21:05:26 <t-bast> Ok, I must be missing on the fundamentals of splicing then...doesn't splicing just spend the funding tx to make a new funding tx for the channel?
21:05:52 <t-bast> Like a close and an open merged in one tx (with the opportunity to dual-fund added)?
21:06:10 <rusty> t-bast: yes, but also adds arbitrary outputs and inputs.  You can propose *another* splice, but it must be at 1.25x (or more) of previous splice feerate.
21:06:30 <t-bast> oh ok so this other splice would replace the previous one entirely?
21:06:41 <rusty> t-bast: we carry all the possible splices until one wins 6 confs.
21:06:50 <rusty> Then we clear them all, and you can propose a new one.
21:06:53 <t-bast> Ok, that's clear now
21:06:55 <t-bast> Thanks
21:07:49 <rusty> If you propose a giant feerate, that's fine, but your peer is unlikely to contribute any changes.  You can ofc make an invalid input and block further splices, but you can always make a channel useless in less exotic ways, too.
21:07:55 <t-bast> Interesting, I can see the synergy with interactive-tx then
21:07:56 <ariard> you should beware of respecting the absolute fee for RBF, otherwise you lastest splice might not propagae
21:08:14 <ariard> though do you really care as long as you expect *any* one of them to confirm?
21:08:20 <rusty> ariard: exactly.
21:08:35 <niftynei> yeah, it's possible you make a non-propagating tx but then you'd just try again?
21:08:38 <rusty> (Though you're right, proposer should check this!)
21:09:05 <rusty> But this is why it kind of goes with splice-to-close, since you can't currently shutdown with outstanding splices.
21:09:09 <ariard> niftynei: nightmare scenario where a reorg occurs, and a parent gets unconfirmed violating bip125 rule 4?
21:09:37 <niftynei> how big of a reorg are you talking?
21:09:38 <ariard> *rule 2 : don't add new unconf input
21:10:14 <ariard> niftynei: even 1-depth reorg is enough to make your transaction not propagating? as a rule of thumb maybe recommend to use parent well-confirmed?
21:11:30 <niftynei> what makes this a nightmare scenario ariard?
21:11:52 <rusty> ariard: yeah, but you can keep sending it to bitcoind and it eventually works once tx is remined.  Unless you're double-spending, which is always possible?
21:12:33 <ariard> niftynei: parent might get double-spent, and you have to adapt your tx construction ?
21:13:05 <rusty> ariard: yeah, that'd cost you 25% bump in fees, but is possible?
21:13:07 <niftynei> iiuc for channel opens, you'd have to RBF the tx *again*. you don't lose anything but time
21:13:24 <niftynei> oh right and the fee bump rate
21:13:56 <rusty> Maybe 25% is too harsh, but as ariard says, if you're using low-confirmed txs you're playing with matches already maybe?
21:13:58 <ariard> niftynei: depends if you have a double-spend in network mempools not signaling rbf, RBF on your side is pretty useless
21:14:16 <niftynei> this could happen with a normal channel open today also, no?
21:14:47 <niftynei> ah wait, no it's a RBF only corner case and you can't rbf an open today. ok
21:15:11 <ariard> niftynei: with a normal channel open, the funder will either double-spend or RBF
21:15:29 <niftynei> you cant RBF an open right now, you'd have to CPFP it
21:15:41 <ariard> with dual-funding or N-funding, each counterparty might have a rebroadcast/differing policy failure
21:16:21 <ariard> like Alice is trying to RBF, but Bob already reaches his funding timer and double-spend his contributed inputs
21:16:30 <niftynei> the mitigation for these corner cases is the same though, no? you double spend an input.
21:16:51 <niftynei> ok so at some point Alice will also hit her funding timer and double-spend her input
21:17:12 <ariard> niftynei: that's a nice failure if both counterparties double-spend their inputs at the same time
21:17:41 <ariard> niftynei: really messy cases it's when your counterparty pin the funding transaction to block your double-spend propagation on the network
21:17:45 <niftynei> does 'at the same time' matter? eventually they should both end up in the same state
21:17:50 <niftynei> true, that does sound messy
21:18:05 <ariard> anyway, i think we'll improve those cooernes cases over time, the core interaction protocol sounds good enough for me :)
21:18:10 <niftynei> any time someone blocks a tx propagation it gets messy haha
21:18:36 <ariard> Package Relay Solves This (or maybe Eltoo?)
21:18:48 <niftynei> PRST !!
21:18:49 <niftynei> haha
21:19:08 <ariard> any other topic or we shutdown here?
21:19:09 <niftynei> cool, thanks for lending your pinning + feerate expertise to the review!
21:19:30 <ariard> niftynei: yw, feel free to ask further questions on the pr :)
21:19:43 <rusty> ariard: I think we're overtime, but good conversation!@
21:20:00 <ariard> yep was a good one
21:20:02 <ariard> #endmeeting