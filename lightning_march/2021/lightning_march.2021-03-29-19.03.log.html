<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<title>#lightning-dev log</title>
<style type="text/css">
/* For the .log.html */
pre { /*line-height: 125%;*/
      white-space: pre-wrap; }
body { background: #f0f0f0; }

body .tm  { color: #007020 }                      /* time */
body .nk  { color: #062873; font-weight: bold }   /* nick, regular */
body .nka { color: #007020; font-weight: bold }  /* action nick */
body .ac  { color: #00A000 }                      /* action line */
body .hi  { color: #4070a0 }                 /* hilights */
/* Things to make particular MeetBot commands stick out */
body .topic     { color: #007020; font-weight: bold }
body .topicline { color: #000080; font-weight: bold }
body .cmd       { color: #007020; font-weight: bold }
body .cmdline  { font-weight: bold }

</style>
</head>

<body>
<pre><a name="l-1"></a><span class="tm">19:03:27</span><span class="nk"> &lt;ariard&gt;</span> <span class="cmd">#startmeeting </span><span class="cmdline">Lightning March</span>
<a name="l-2"></a><span class="tm">19:03:27</span><span class="nk"> &lt;lndev-bot&gt;</span> Meeting started Mon Mar 29 19:03:27 2021 UTC and is due to finish in 60 minutes.  The chair is ariard. Information about MeetBot at http://wiki.debian.org/MeetBot.
<a name="l-3"></a><span class="tm">19:03:27</span><span class="nk"> &lt;lndev-bot&gt;</span> Useful Commands: #action #agreed #help #info #idea #link #topic #startvote.
<a name="l-4"></a><span class="tm">19:03:27</span><span class="nk"> &lt;lndev-bot&gt;</span> The meeting name has been set to 'lightning_march'
<a name="l-5"></a><span class="tm">19:03:39</span><span class="nk"> &lt;t-bast&gt;</span> yep it's the 2021 edition of the bot that requires a meeting name, got me last time as well
<a name="l-6"></a><span class="tm">19:03:54</span><span class="nk"> &lt;rusty&gt;</span> Hello everyone!  I am finally enjoying my "bitcoin-hit-50k" espresso machine... I will be awake in a moment.
<a name="l-7"></a><span class="tm">19:03:57</span><span class="nk"> &lt;ariard&gt;</span> # topic  #847 closing fee requirement
<a name="l-8"></a><span class="tm">19:03:58</span><span class="nk"> &lt;t-bast&gt;</span> hey vincenzopalazzo
<a name="l-9"></a><span class="tm">19:04:09</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">rusty:</span> nice!
<a name="l-10"></a><span class="tm">19:04:20</span><span class="nk"> &lt;cdecker&gt;</span> <span class="hi">rusty:</span> a coffee machine for a full bitcoin? That must be a steam engine :-)
<a name="l-11"></a><span class="tm">19:04:46</span><span class="nk"> &lt;ariard&gt;</span> who has done an implementation of #847, beyond eclair ? any feedback
<a name="l-12"></a><span class="tm">19:05:04</span><span class="nk"> &lt;t-bast&gt;</span> re #847, the only thing I changed is adding a TLV to specify the fee range we're ok with paying
<a name="l-13"></a><span class="tm">19:05:28</span><span class="nk"> &lt;ariard&gt;</span> with lower-upper bound ?
<a name="l-14"></a><span class="tm">19:05:35</span><span class="nk"> &lt;t-bast&gt;</span> yes, it's a min-fee and a max-fee
<a name="l-15"></a><span class="tm">19:06:20</span><span class="nk"> &lt;t-bast&gt;</span> it doesn't solve the case where you completely disagree with your peer's fee range though: but in that case negotiation would kind of fail anyway...
<a name="l-16"></a><span class="tm">19:06:45</span><span class="nk"> &lt;ariard&gt;</span> would it make sense to express per wu ? in case we reuse this for splicing and closing may be far bigger
<a name="l-17"></a><span class="tm">19:06:49</span><span class="nk"> &lt;t-bast&gt;</span> and it seems like the only option is to force-close (but there may be a game of chicken to get the other guy to force-close to avoid csv delays)
<a name="l-18"></a><span class="tm">19:07:02</span><span class="nk"> &lt;niftynei&gt;</span> can the feerange change between `closing_signed` messages?
<a name="l-19"></a><span class="tm">19:07:25</span><span class="nk"> &lt;niftynei&gt;</span> if not, it might make sense to add it to the `shutdown` request instead? or is that too far from the closing logic
<a name="l-20"></a><span class="tm">19:07:37</span><span class="nk"> &lt;t-bast&gt;</span> I chose to stick to fee values instead of feerate to be consistent with the fee in the `closing_signed` message, but I can make that a feerate instead if we feel that's the direction we want to take in the spec
<a name="l-21"></a><span class="tm">19:08:22</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">niftynei:</span> it's a good point, I'm not sure it should change, but `shutdown` may be too early: if it takes a lot of time to settle pending HTLCs, on-chain fees may have changed drastically
<a name="l-22"></a><span class="tm">19:09:10</span><span class="nk"> &lt;t-bast&gt;</span> but I don't know if we should require this range to be fixed: if your peer goes offline and comes back online an hour later, you'll want to resume negotiation but fees will have changes
<a name="l-23"></a><span class="tm">19:09:12</span><span class="nk"> &lt;niftynei&gt;</span> so on clightning we've been musing about applying the interactive tx protocol to closing; a feerate would be more flexible in that case, as the size of the tx is variable. right now closing tx's are fixed format, no?
<a name="l-24"></a><span class="tm">19:09:13</span><span class="nk"> &lt;t-bast&gt;</span> *changed
<a name="l-25"></a><span class="tm">19:09:23</span><span class="nk"> &lt;niftynei&gt;</span> ah i see, good point
<a name="l-26"></a><span class="tm">19:09:31</span><span class="nk"> &lt;ariard&gt;</span> closing tx are fixed format with either one or two outputs iirc
<a name="l-27"></a><span class="tm">19:09:50</span><span class="nk"> &lt;t-bast&gt;</span> yes, that's because the closing tx is fixed that I left it a flat fee since you can instantly convert to feerate, but you're right that feerate may be more flexible long term
<a name="l-28"></a><span class="tm">19:10:27</span><span class="nk"> &lt;niftynei&gt;</span> in the ideal case, you only ever exchange three closing_signed messages? the one setting the feerate range, your peer which picks out a feerate in that range and then your matching response?
<a name="l-29"></a><span class="tm">19:10:31</span><span class="nk"> &lt;rusty&gt;</span> AFAICT range is just for post-mortem purposes really?  If you don't agree, you can show the ranges...
<a name="l-30"></a><span class="tm">19:10:53</span><span class="nk"> &lt;ariard&gt;</span> right, there is no fall-back to get back the negotiation with looser range
<a name="l-31"></a><span class="tm">19:11:06</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">niftynei:</span> yes exactly, but you're also free to continue negotiating inside the fee range to get closer to your "ideal" fee
<a name="l-32"></a><span class="tm">19:11:20</span><span class="nk"> &lt;niftynei&gt;</span> why not set the range to exactly the ideal fee then?
<a name="l-33"></a><span class="tm">19:11:20</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">rusty:</span> what do you mean by post-mortem here?
<a name="l-34"></a><span class="tm">19:11:54</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">niftynei:</span> you mean sending a single value? That's already what we do now, isn't it?
<a name="l-35"></a><span class="tm">19:12:29</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> you could continue using the existing protocol and ignore it, but at least print it out if negotiation fails so user can see what went wrong.  But I guess more optimal to do as niftynei says: pick something in this range immediately.
<a name="l-36"></a><span class="tm">19:12:39</span><span class="nk"> &lt;vincenzopalazzo&gt;</span> Sorry for the stupid question, for me, it is the first time for me here. There is some secret door to enter in the meeting to hear only? :-)
<a name="l-37"></a><span class="tm">19:13:02</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">rusty:</span> gotcha, yes with older nodes who ignore this range entirely it would help users understand why things went sour
<a name="l-38"></a><span class="tm">19:13:25</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">vincenzopalazzo:</span> the meeting is IRC only, no voice/video call, you're already in ;)
<a name="l-39"></a><span class="tm">19:13:29</span><span class="nk"> &lt;cdecker&gt;</span> <span class="hi">vincenzopalazzo:</span> you're already in it, we moved the discussion to IRC to include everyone
<a name="l-40"></a><span class="tm">19:13:51</span><span class="nk"> &lt;vincenzopalazzo&gt;</span> ops :-D sorry
<a name="l-41"></a><span class="tm">19:14:17</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">vincenzopalazzo:</span> welcome among us :)
<a name="l-42"></a><span class="tm">19:14:39</span><span class="nk"> &lt;vincenzopalazzo&gt;</span> Thanks ariard :)
<a name="l-43"></a><span class="tm">19:14:59</span><span class="nk"> &lt;t-bast&gt;</span> the ideal behavior (in my opinion) would be: I send you a feerange and my preferred fee, if you completely disagree with the fee-range just force-close or ignore, if you agree with the fee range choose something inside it and we close the negotiation
<a name="l-44"></a><span class="tm">19:15:22</span><span class="nk"> &lt;t-bast&gt;</span> the risk is whether implementations/users will be aggressive and chose a narrow fee-range, resulting in a lot of disagreement / force-close
<a name="l-45"></a><span class="tm">19:15:22</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> OK, this seems perfectly implementable.  For dual-funding we used a "min, preferred, max" and the other side simply chose.  This is pretty close to that.
<a name="l-46"></a><span class="tm">19:16:00</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">rusty:</span> I only added min and max since preferred is already in the closing_signed, but if we move to feerates I'll add preferred inside the TLV to make it more obvious
<a name="l-47"></a><span class="tm">19:16:05</span><span class="nk"> &lt;niftynei&gt;</span> well that was in a draft but it's since been removed lol &gt;.&lt;
<a name="l-48"></a><span class="tm">19:16:22</span><span class="nk"> &lt;t-bast&gt;</span> <span class="cmd">#action </span><span class="cmdline">t-bast to use feerates instead of flat fees and add preferred in the fee_range tlv</span>
<a name="l-49"></a><span class="tm">19:16:36</span><span class="nk"> &lt;ariard&gt;</span> okay we're good next topic?
<a name="l-50"></a><span class="tm">19:16:40</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> you're right, it's exactly analogous.  Leave it as is, I say.  It maps really well.
<a name="l-51"></a><span class="tm">19:16:41</span><span class="nk"> &lt;t-bast&gt;</span> ACK
<a name="l-52"></a><span class="tm">19:16:52 </span><span class="nka">* rusty</span> <span class="ac">acks as is</span>
<a name="l-53"></a><span class="tm">19:17:05</span><span class="nk"> &lt;ariard&gt;</span> # topic Funding timeout recovery proposal #854
<a name="l-54"></a><span class="tm">19:18:04</span><span class="nk"> &lt;cdecker&gt;</span> Yeah, so the idea is pretty simple, and I think well worth the extra couple of bytes to remember in order to have a gracious close
<a name="l-55"></a><span class="tm">19:18:04</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">cdecker:</span> you want to explain for the ones for have not dig into this :) ?
<a name="l-56"></a><span class="tm">19:19:12</span><span class="nk"> &lt;cdecker&gt;</span> The idea basically is that since we all derive the per-channel key in a secure way (HKDF) we can freely use it to sign anything that looks like a transaction once we're sure we're not going to make progress with that channel, i.e., we gave up waiting for it to confirm
<a name="l-57"></a><span class="tm">19:19:46</span><span class="nk"> &lt;cdecker&gt;</span> One alternative would have been to just share the private key, but that feels wrong, but signing is fine
<a name="l-58"></a><span class="tm">19:20:21</span><span class="nk"> &lt;cdecker&gt;</span> We sign a close transaction with a sighash_none so the funder can chose a feerate it feels comfortable with and could RBF bump as well
<a name="l-59"></a><span class="tm">19:20:23</span><span class="nk"> &lt;ariard&gt;</span> sharing the private key sounds a restriction on your signer implementation
<a name="l-60"></a><span class="tm">19:20:34</span><span class="nk"> &lt;t-bast&gt;</span> but if you're signing blindly, isn't it the same thing as giving away the private key?
<a name="l-61"></a><span class="tm">19:20:57</span><span class="nk"> &lt;t-bast&gt;</span> because signing with sighash_none is really equivalent to signing blindly, isn't it?
<a name="l-62"></a><span class="tm">19:21:01</span><span class="nk"> &lt;ariard&gt;</span> giving away a private key may reveal information about derivation scheme
<a name="l-63"></a><span class="tm">19:21:04</span><span class="nk"> &lt;cdecker&gt;</span> We're not quite signing blindly, we're signing valid transactions spending the channel funding outpoint should it ever be confirmed
<a name="l-64"></a><span class="tm">19:21:19</span><span class="nk"> &lt;ariard&gt;</span> after the timeout
<a name="l-65"></a><span class="tm">19:21:44</span><span class="nk"> &lt;t-bast&gt;</span> true, it's more restrictive, I guess you've explored potential signature re-use?
<a name="l-66"></a><span class="tm">19:22:03</span><span class="nk"> &lt;t-bast&gt;</span> there's probably none since we marked the channel as never being used
<a name="l-67"></a><span class="tm">19:22:28</span><span class="nk"> &lt;cdecker&gt;</span> Per spec the bitcoin privkey should be derived in a hardened way from the channel parameters, so we automatically use different keys for different channels
<a name="l-68"></a><span class="tm">19:22:49</span><span class="nk"> &lt;cdecker&gt;</span> So any issue is restricted to within that channel
<a name="l-69"></a><span class="tm">19:22:55</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">ariard:</span> how so? if you're using bip32 with non-hardened?
<a name="l-70"></a><span class="tm">19:23:07</span><span class="nk"> &lt;cdecker&gt;</span> Inside the channel we already gave up and don't have a stake in anymore
<a name="l-71"></a><span class="tm">19:23:24</span><span class="nk"> &lt;t-bast&gt;</span> right, so if the spec mandates using hardened derivation, is there a risk sharing the private key?
<a name="l-72"></a><span class="tm">19:23:50</span><span class="nk"> &lt;cdecker&gt;</span> Unless we have a bug and decide to accept a confirmation as an open it can be dangerous, but then the implementation is pretyt broken anyway :-)
<a name="l-73"></a><span class="tm">19:23:53</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">t-bast:</span> is the spec making mandatory to use bip32 ? our signer interface in RL doesn't make this assumption
<a name="l-74"></a><span class="tm">19:24:01</span><span class="nk"> &lt;t-bast&gt;</span> because that would solve users mistakingly sending *more* money to the 2-of-2 by mistake when trying to CPFP/RBF the funding tx...
<a name="l-75"></a><span class="tm">19:24:26</span><span class="nk"> &lt;cdecker&gt;</span> Uh, interesting use-case, thanks t-bast for pointint that out
<a name="l-76"></a><span class="tm">19:25:03</span><span class="nk"> &lt;cdecker&gt;</span> As the second part says, we'd also like an automated recovery for the case the funding tx was malleated, which is a special case of what you mention
<a name="l-77"></a><span class="tm">19:25:16</span><span class="nk"> &lt;rusty&gt;</span> Yeah, the private key solves all the problems the user can create (so they can create new oens!).
<a name="l-78"></a><span class="tm">19:25:17</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">cdecker:</span> that actually happened to one of our users, so we had to help them sign another tx to get their funds back...t
<a name="l-79"></a><span class="tm">19:25:38</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> yech... we don't like our users as much as you like yours :)
<a name="l-80"></a><span class="tm">19:25:41</span><span class="nk"> &lt;cdecker&gt;</span> Yep, that's how we discovered it as well ;-)
<a name="l-81"></a><span class="tm">19:25:58</span><span class="nk"> &lt;t-bast&gt;</span> I'm not finding anywhere in the spec where we mandate or advise using hardened derivation though...
<a name="l-82"></a><span class="tm">19:26:07</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">rusty:</span> a pleasure to serve ;)
<a name="l-83"></a><span class="tm">19:26:43</span><span class="nk"> &lt;cdecker&gt;</span> <span class="hi">t-bast:</span> I was absolutely convinced it'd be there, and didn't bother to check. Is anyone using non-hardened derivation anyway?
<a name="l-84"></a><span class="tm">19:26:50</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> yeah, don't implement this if your keys aren't hardened!
<a name="l-85"></a><span class="tm">19:27:27</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">cdecker:</span>  we have an abstract interface in RL, outside our scope to mandate hardened or non-hardened
<a name="l-86"></a><span class="tm">19:27:41</span><span class="nk"> &lt;niftynei&gt;</span> signing an 'arbitrary' tx with non-hardened keys is fine, no? it'd just be problematic if you exposed the privkey
<a name="l-87"></a><span class="tm">19:28:19</span><span class="nk"> &lt;cdecker&gt;</span> Hm, so this complicates things a bit. Do you have signals on whether hardened or non-hardened derivation was used?
<a name="l-88"></a><span class="tm">19:29:08</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">cdecker:</span> no though we could tweak our api
<a name="l-89"></a><span class="tm">19:29:13</span><span class="nk"> &lt;t-bast&gt;</span> But is there a reason why you'd use non-hardened derivation? I'm not sure it makes sense anywhere to get the benefits of those compared to hardened derivation for channel keys, is there?
<a name="l-90"></a><span class="tm">19:29:40</span><span class="nk"> &lt;cdecker&gt;</span> <span class="hi">ariard:</span> do the rust thing and add a new type? xD
<a name="l-91"></a><span class="tm">19:29:58 </span><span class="nka">* cdecker</span> <span class="ac">is learning rust ;-)</span>
<a name="l-92"></a><span class="tm">19:30:00</span><span class="nk"> &lt;t-bast&gt;</span> Or is there some clever thing for watchtowers or something where it's helpful to use non-hardened somehow?
<a name="l-93"></a><span class="tm">19:30:00</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">cdecker:</span> but do we really want to share private key ?
<a name="l-94"></a><span class="tm">19:30:22</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">t-bast:</span> well that's the thing, try to be flexible for things we're not smart enough to guess
<a name="l-95"></a><span class="tm">19:30:24</span><span class="nk"> &lt;cdecker&gt;</span> Ah no, that'd be the alternative, in this draft we just sign with sighash_none
<a name="l-96"></a><span class="tm">19:30:50</span><span class="nk"> &lt;ariard&gt;</span> i would need to ask devrandom opinion he has a sample signer
<a name="l-97"></a><span class="tm">19:30:54</span><span class="nk"> &lt;t-bast&gt;</span> it feels to me that this is an area where we'd lock things down by default because it critical though
<a name="l-98"></a><span class="tm">19:31:06</span><span class="nk"> &lt;cdecker&gt;</span> Not a cryptographer, but if someone convinces me that non-hardened + signing only valid txs is ok, then I'll happily accept that :-)
<a name="l-99"></a><span class="tm">19:31:11</span><span class="nk"> &lt;ariard&gt;</span> what supplemental advantage do we get from using private key compare to sighash none?
<a name="l-100"></a><span class="tm">19:31:20</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">ariard:</span> it's a better solution.  It lets them do whatever they want, has no onchain privacy issues....
<a name="l-101"></a><span class="tm">19:31:24</span><span class="nk"> &lt;t-bast&gt;</span> but I can understand the reasoning to let users find use-cases, in that case we should forget about the option to dump the private key
<a name="l-102"></a><span class="tm">19:31:35</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">rusty:</span> onchain privacy issue is a good point
<a name="l-103"></a><span class="tm">19:32:08</span><span class="nk"> &lt;cdecker&gt;</span> Yep, wasn't it ariard that pointed out that sighash_none is a tracing capability?
<a name="l-104"></a><span class="tm">19:32:17</span><span class="nk"> &lt;ariard&gt;</span> though the 2048 delay is a good enough fingerprint
<a name="l-105"></a><span class="tm">19:32:25</span><span class="nk"> &lt;ariard&gt;</span> like utxo age
<a name="l-106"></a><span class="tm">19:33:01</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">ariard:</span> but this solution works when we head to taproot, too, which is a minor consideration but kinda nice.
<a name="l-107"></a><span class="tm">19:33:02</span><span class="nk"> &lt;cdecker&gt;</span> I mean we could counteract that and have the funder propose a close and the fundee signs it (without sighash_none), that could be iterated
<a name="l-108"></a><span class="tm">19:33:23</span><span class="nk"> &lt;ariard&gt;</span> i would consider this like an edge case, like unilateral closing we also loose privacy
<a name="l-109"></a><span class="tm">19:33:26</span><span class="nk"> &lt;cdecker&gt;</span> But the sighash_none sig has the nice advantage of not requiring interaction if things don't work out (RBF bump, ...)
<a name="l-110"></a><span class="tm">19:33:32</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">rusty:</span> right, if we cant make it work with the private key, its not gonna work on taproot, so we should find a way to make it work, no?
<a name="l-111"></a><span class="tm">19:33:43</span><span class="nk"> &lt;BlueMatt&gt;</span> ie, we're gonna wanna use the private key come taproot, anyway
<a name="l-112"></a><span class="tm">19:33:54 </span><span class="nka">* BlueMatt</span> <span class="ac">will figure his calendar out and show up on time one day...just not today</span>
<a name="l-113"></a><span class="tm">19:34:29</span><span class="nk"> &lt;ariard&gt;</span> sighash_none is great to avoid the non-interactivity agree
<a name="l-114"></a><span class="tm">19:34:29</span><span class="nk"> &lt;cdecker&gt;</span> Interesting, I don't quite get the connection with taproot yet, BlueMatt can you help me?
<a name="l-115"></a><span class="tm">19:35:01</span><span class="nk"> &lt;cdecker&gt;</span> Oh, I see, must've missed the msg you were referring to, sorry
<a name="l-116"></a><span class="tm">19:35:02</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">cdecker:</span> as in, once we have taproot funding outputs, we can't do sighash-none if you want to allow spends to be key-based and not reveal-script-based
<a name="l-117"></a><span class="tm">19:35:03</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">cdecker:</span> if you have to use musig2 to co-create a signature, that would be a different post-close signing flow I think.
<a name="l-118"></a><span class="tm">19:35:05</span><span class="nk"> &lt;t-bast&gt;</span> we could use that sighash_none on chain to detect people who have a buggy CPFP engine xD
<a name="l-119"></a><span class="tm">19:35:07</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">cdecker:</span> because aggregated pubkey requiring signing interactivity
<a name="l-120"></a><span class="tm">19:35:24</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">t-bast:</span> re #847, havne't done it yet inlnd but I plan to get a PR up on the lnd side this week
<a name="l-121"></a><span class="tm">19:35:31</span><span class="nk"> &lt;BlueMatt&gt;</span> in the non-taproot world I dont think its worth worrying too much about the privacy, but in taproot probably does
<a name="l-122"></a><span class="tm">19:35:44 </span><span class="nka">* cdecker</span> <span class="ac">ducks from all the explanations xD</span>
<a name="l-123"></a><span class="tm">19:36:22</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">roasbeef:</span> nice, don't hesitate to ping me when you have a branch available, I can run some interop tests then
<a name="l-124"></a><span class="tm">19:38:06</span><span class="nk"> &lt;niftynei&gt;</span> so it sounds like "requesting sig from peer" rather than "requesting privkey from peer" is going to forward compatible... and/or that we'll need to update/change the interaction once taproot is standard?
<a name="l-125"></a><span class="tm">19:38:22</span><span class="nk"> &lt;niftynei&gt;</span> *is going to be forward compatible
<a name="l-126"></a><span class="tm">19:38:54</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">niftynei:</span> no, getting privkey is ultimately fwd compatible.  IMHO it'd be the clear winner but for our instinct to NEVER EVER DO THAT.
<a name="l-127"></a><span class="tm">19:38:57</span><span class="nk"> &lt;t-bast&gt;</span> IIUC we're saying that sighash_none will not work with taproot, isn't it?
<a name="l-128"></a><span class="tm">19:39:07</span><span class="nk"> &lt;niftynei&gt;</span> ack, thanks!
<a name="l-129"></a><span class="tm">19:39:21</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">t-bast:</span> it would, it would just create a larger transaction and reveal the spending condition, which we'd ideally not do
<a name="l-130"></a><span class="tm">19:39:29</span><span class="nk"> &lt;cdecker&gt;</span> Yeah, that's too bad
<a name="l-131"></a><span class="tm">19:39:33</span><span class="nk"> &lt;t-bast&gt;</span> at least that sighash_none will not give us the non-interactivity if we want to use the keypath
<a name="l-132"></a><span class="tm">19:39:39</span><span class="nk"> &lt;ariard&gt;</span> though you're back loosing privacy
<a name="l-133"></a><span class="tm">19:39:49</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">BlueMatt:</span> right, exactly
<a name="l-134"></a><span class="tm">19:40:30</span><span class="nk"> &lt;cdecker&gt;</span> How about the iterated "ask peer for sig" approach, and we tell the fundee what sighash we'd like?
<a name="l-135"></a><span class="tm">19:40:32</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">ariard:</span> wrt rust-lightning's key interface, we'll probably have to, eg, take the private key the user gives us and hash it to create a new one or something trivial.
<a name="l-136"></a><span class="tm">19:40:36</span><span class="nk"> &lt;rusty&gt;</span> I say let's leak the private key YOLO!
<a name="l-137"></a><span class="tm">19:40:54</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">BlueMatt:</span> right hashing should break any information leak
<a name="l-138"></a><span class="tm">19:41:03</span><span class="nk"> &lt;cdecker&gt;</span> If the node is responsive they can do without sighash_none, while if we don't think our peer will be around we can use sh_none
<a name="l-139"></a><span class="tm">19:41:20</span><span class="nk"> &lt;niftynei&gt;</span> the problem with leaking the private key iiuc was that RL doesn't guarantee their keys are per-channel hardened, right?
<a name="l-140"></a><span class="tm">19:41:39</span><span class="nk"> &lt;cdecker&gt;</span> <span class="hi">KEYOLO:</span> a key that only lives once xD
<a name="l-141"></a><span class="tm">19:41:54</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">niftynei:</span> we do, but hardened specifically is up to users how they want to derive keys. we can, however, force users to give us a hash preimage of the key instead, allowing us to "force" them to be "hardeneed" by hashing them
<a name="l-142"></a><span class="tm">19:42:27</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">cdecker:</span> love it, I want you on the marketing team for feature names xD
<a name="l-143"></a><span class="tm">19:42:28</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">niftynei:</span> oh, I misread your text, but, no, yea, we do *not* require them to be hardened per-channel (though obviously default implementations do)
<a name="l-144"></a><span class="tm">19:42:43</span><span class="nk"> &lt;niftynei&gt;</span> ack
<a name="l-145"></a><span class="tm">19:42:58</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">BlueMatt:</span> not hardened but unique per-channel
<a name="l-146"></a><span class="tm">19:43:10</span><span class="nk"> &lt;BlueMatt&gt;</span> right, we (obviously) require unique-per-channel, but not hardneded
<a name="l-147"></a><span class="tm">19:43:13</span><span class="nk"> &lt;BlueMatt&gt;</span> anyway, next topic?
<a name="l-148"></a><span class="tm">19:43:18</span><span class="nk"> &lt;BlueMatt&gt;</span> sounds like everyone's in agreement?
<a name="l-149"></a><span class="tm">19:43:33</span><span class="nk"> &lt;ariard&gt;</span> # Long Term Updates
<a name="l-150"></a><span class="tm">19:43:39</span><span class="nk"> &lt;t-bast&gt;</span> in agreement with dumping the priv key?
<a name="l-151"></a><span class="tm">19:43:42</span><span class="nk"> &lt;roasbeef&gt;</span> ah interesting, this would also be a way to just get rid of the half baked "fee neogitation" in the spec rn re rusty's comment on the spec
<a name="l-152"></a><span class="tm">19:43:42</span><span class="nk"> &lt;niftynei&gt;</span> sounds like there might be a TODO here to add a "must be hardened" note to the channel keys in the spec?
<a name="l-153"></a><span class="tm">19:44:16</span><span class="nk"> &lt;cdecker&gt;</span> So my conclusions from #854 are: a) general agreement that this is a useful feature, b) we need to discuss whether to leak key or serve sigs, is this about correct?
<a name="l-154"></a><span class="tm">19:44:23</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">niftynei:</span> yeah, don't support this option unless key is hardened.
<a name="l-155"></a><span class="tm">19:44:29</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> yeah, it seems to devolve down to it?
<a name="l-156"></a><span class="tm">19:44:37</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">niftynei:</span> no, no need, just a note that the keys should not reveal information about other keys - that can be accomplished in many ways with or without bip 32
<a name="l-157"></a><span class="tm">19:44:52</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">cdecker:</span> i was dubious about the funding transaction alias
<a name="l-158"></a><span class="tm">19:44:53</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">cdecker:</span> oh, sorry, i thought we were largely all in agreement to reveal the secret key
<a name="l-159"></a><span class="tm">19:45:07</span><span class="nk"> &lt;niftynei&gt;</span> i had reached the same conclusion as BlueMatt fwiw
<a name="l-160"></a><span class="tm">19:45:24</span><span class="nk"> &lt;cdecker&gt;</span> Ok, sounds good to me, I can draft up the changes accordingly 👍
<a name="l-161"></a><span class="tm">19:45:38</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">cdecker:</span> but not a concern anymore if you're giving the key away ahah
<a name="l-162"></a><span class="tm">19:45:58</span><span class="nk"> &lt;cdecker&gt;</span> <span class="hi">ariard:</span> the funding tx alias is there for funding tx malleation, which happened to perfectly fit in this proposal
<a name="l-163"></a><span class="tm">19:46:09</span><span class="nk"> &lt;niftynei&gt;</span> option SIGHASH_SEND_KEY
<a name="l-164"></a><span class="tm">19:46:09</span><span class="nk"> &lt;rusty&gt;</span> - MUST print out "KEYOLO" in the logs when revealing the private key.
<a name="l-165"></a><span class="tm">19:46:12</span><span class="nk"> &lt;cdecker&gt;</span> Right, that'd be the sledgehammer approach
<a name="l-166"></a><span class="tm">19:46:30</span><span class="nk"> &lt;t-bast&gt;</span> YAY dump all the private keys!
<a name="l-167"></a><span class="tm">19:46:32</span><span class="nk"> &lt;ariard&gt;</span> ultimate malleability delegation xD
<a name="l-168"></a><span class="tm">19:46:50</span><span class="nk"> &lt;cdecker&gt;</span> See, no need for segwit if we can fix malleability this way xD
<a name="l-169"></a><span class="tm">19:46:57</span><span class="nk"> &lt;cdecker&gt;</span> Anyway
<a name="l-170"></a><span class="tm">19:46:59</span><span class="nk"> &lt;ariard&gt;</span> do you want to talk about a long-term updates ?
<a name="l-171"></a><span class="tm">19:47:07</span><span class="nk"> &lt;niftynei&gt;</span> yes!
<a name="l-172"></a><span class="tm">19:47:09</span><span class="nk"> &lt;ariard&gt;</span> which one ?
<a name="l-173"></a><span class="tm">19:47:10</span><span class="nk"> &lt;cdecker&gt;</span> <span class="cmd">#action </span><span class="cmdline">cdecker to draft up the proposal with KEYOLO</span>
<a name="l-174"></a><span class="tm">19:47:23</span><span class="nk"> &lt;niftynei&gt;</span> dual funding! #851
<a name="l-175"></a><span class="tm">19:47:29</span><span class="nk"> &lt;roasbeef&gt;</span> +1 for sighash_none vs sending keys over
<a name="l-176"></a><span class="tm">19:47:31</span><span class="nk"> &lt;ariard&gt;</span> let's go for dual-funding :)
<a name="l-177"></a><span class="tm">19:48:06</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">roasbeef:</span> hmmm are you for sighash_none or sending keys over?
<a name="l-178"></a><span class="tm">19:48:18</span><span class="nk"> &lt;cdecker&gt;</span> <span class="topic">#topic </span><span class="topicline">Long Term Update: Dual Funding</span>
<a name="l-179"></a><span class="tm">19:48:27</span><span class="nk"> &lt;cdecker&gt;</span> <span class="cmd">#link </span><span class="cmdline">https://github.com/lightningnetwork/lightning-rfc/pull/851</span>
<a name="l-180"></a><span class="tm">19:48:46</span><span class="nk"> &lt;t-bast&gt;</span> how do you recommend we read the PR niftynei: is there a simple path for reviewers before diving into concrete requirements?
<a name="l-181"></a><span class="tm">19:48:59</span><span class="nk"> &lt;niftynei&gt;</span> ok just a quick update! we've got an implementation i'm fairly happy with in c-lightning and are planning to ship it (flagged behind a runtime experimental flag) in our next release (coming.. this week?)
<a name="l-182"></a><span class="tm">19:49:42</span><span class="nk"> &lt;niftynei&gt;</span> the PR for the spec change is listed (minus the feerate ranges that rusty mentioned, they were taken out later lol)
<a name="l-183"></a><span class="tm">19:50:08</span><span class="nk"> &lt;niftynei&gt;</span> <span class="hi">t-bast:</span> do you mean like the "one sheet summary"?
<a name="l-184"></a><span class="tm">19:50:39</span><span class="nk"> &lt;niftynei&gt;</span> i did a short infomercial on the spec changes late last thursday, i'll post it here as soon as it's up on youtube. that might be useful for approaching the spec
<a name="l-185"></a><span class="tm">19:50:45</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">niftynei:</span> like the more digestable higher-level format (ideally with diagrams and flows) :)
<a name="l-186"></a><span class="tm">19:51:06</span><span class="nk"> &lt;niftynei&gt;</span> there are diagrams and flows in the spec itself
<a name="l-187"></a><span class="tm">19:51:22</span><span class="nk"> &lt;t-bast&gt;</span> right, I just reached them!
<a name="l-188"></a><span class="tm">19:51:24</span><span class="nk"> &lt;rusty&gt;</span> (Side note: Damn, second espresso is really good...)
<a name="l-189"></a><span class="tm">19:51:39</span><span class="nk"> &lt;ariard&gt;</span> the fee bumping model is single-party rbf ?
<a name="l-190"></a><span class="tm">19:51:41</span><span class="nk"> &lt;niftynei&gt;</span> rusty you're bringing that coffee machine to the next in-person yeah??
<a name="l-191"></a><span class="tm">19:51:50</span><span class="nk"> &lt;niftynei&gt;</span> ariard, what's a single-party rbf?
<a name="l-192"></a><span class="tm">19:51:51</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">ariard:</span> sighash_none, re the taproot thing we'd need a different co-op closing scheme all together in either case right?
<a name="l-193"></a><span class="tm">19:52:05</span><span class="nk"> &lt;roasbeef&gt;</span> as that's more interactive
<a name="l-194"></a><span class="tm">19:52:16</span><span class="nk"> &lt;lnd-bot&gt;</span> [13lightning-rfc] 15btcontract closed pull request #857: Add keysend invoice (06master...06master) 02https://github.com/lightningnetwork/lightning-rfc/pull/857
<a name="l-195"></a><span class="tm">19:52:29</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">niftynei:</span> if we can fit/convince/swing the chaincode office there's already a quite nice machine there :)
<a name="l-196"></a><span class="tm">19:52:42</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">niftynei:</span> it's 30kg (40kg boxed), so might be cheaper to buy a second one and ship it from Italy...
<a name="l-197"></a><span class="tm">19:52:45</span><span class="nk"> &lt;niftynei&gt;</span> the rbf is initiated by the opener, same as the open_channel2 is; it's basically a request to re-do the opening but with a higher feerate
<a name="l-198"></a><span class="tm">19:52:48</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">roasbeef:</span> but we all conclude that private key was far more flexible and taproot-proof ? we might have closing scheme for taproot for sure
<a name="l-199"></a><span class="tm">19:53:16</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">niftynei:</span> that's what i meant rbf is initiated on the burden of one-party
<a name="l-200"></a><span class="tm">19:53:42</span><span class="nk"> &lt;niftynei&gt;</span> both parties pay fees on the funding tx, so re-doing the tx is kind of a must (or the other party can refuse to contribute funds on the RBF if they don't like the feerate)
<a name="l-201"></a><span class="tm">19:53:54</span><span class="nk"> &lt;cdecker&gt;</span> Not exactly, we restart from the beginning and the feerate is shared by both parties
<a name="l-202"></a><span class="tm">19:54:09</span><span class="nk"> &lt;ariard&gt;</span> we had this interesting discussion with dlc, which is dual-funded from beginning, if the fundee should compensate funder with a premium fee for mempool congestion aleas
<a name="l-203"></a><span class="tm">19:54:42</span><span class="nk"> &lt;ariard&gt;</span> i don't propose to introduce such thing rn we might think about it in the future
<a name="l-204"></a><span class="tm">19:54:59</span><span class="nk"> &lt;roasbeef&gt;</span> so with funding rbf, impl wise both sides need to be ready to ensure they can act if any of the prior versions confirms right?
<a name="l-205"></a><span class="tm">19:55:09</span><span class="nk"> &lt;BlueMatt&gt;</span> side-note- what time{,zone} is this meeting, anwyway? my calendar entry *was* off...
<a name="l-206"></a><span class="tm">19:55:19</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">BlueMatt:</span> I think it's adelaide time
<a name="l-207"></a><span class="tm">19:55:21</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">ariard:</span> we have extra flexibility, since there's always the option of withdrawing your funds from channel....
<a name="l-208"></a><span class="tm">19:55:25</span><span class="nk"> &lt;niftynei&gt;</span> roasbeef, yes that's correct. it's a lot like splicing in that way
<a name="l-209"></a><span class="tm">19:55:37</span><span class="nk"> &lt;rusty&gt;</span> Indeed, which means NEXT MEETING will be 1 hour different in UTC BTW.
<a name="l-210"></a><span class="tm">19:55:39</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">roasbeef:</span> huh. what time adelaide? google and local cilents disagree :/
<a name="l-211"></a><span class="tm">19:55:58</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">rusty:</span> right you might be more interested to keep going the confirmation attempt as you're economically interested by this channel attempt
<a name="l-212"></a><span class="tm">19:56:13</span><span class="nk"> &lt;roasbeef&gt;</span> gotcha cool, we we're looking to impl something similar on the context of pool to be able to implement batch cut-through (so compressing N unconfirmed batches into a single transaction)
<a name="l-213"></a><span class="tm">19:56:13</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">BlueMatt:</span> 5:30am Adelaide.
<a name="l-214"></a><span class="tm">19:56:37</span><span class="nk"> &lt;ariard&gt;</span> though fee bumping doesn't have to as aggresive that for justice transaction
<a name="l-215"></a><span class="tm">19:57:06</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">niftynei:</span> zooming out a bit and going through the PR quickly, did you solve how that could be used as an oracle to discover someone's utxos?
<a name="l-216"></a><span class="tm">19:57:15</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> yeah, because it's (bascially) a complete renegotiation (with req that fees increase by at least 25%) you can mix and match existing ones.
<a name="l-217"></a><span class="tm">19:57:53</span><span class="nk"> &lt;niftynei&gt;</span> no i punted based on the email discussion from lloyd fournier/rusty wrt to PoDLEs versus signed 'bond' txs
<a name="l-218"></a><span class="tm">19:58:47</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> yes, Lloyd convinced me that it wasn't worth the trouble for the short term, given the number of other ways to identify channel UTXOs.  Mainly because it's easy to add later...
<a name="l-219"></a><span class="tm">19:58:47</span><span class="nk"> &lt;niftynei&gt;</span> the general take away was that your onchain privacy isnt' very good anyway; we can implement PoDLEs later to mitigate
<a name="l-220"></a><span class="tm">19:59:14</span><span class="nk"> &lt;niftynei&gt;</span> it's very straightforward to add later on
<a name="l-221"></a><span class="tm">19:59:19</span><span class="nk"> &lt;t-bast&gt;</span> ok, thanks, good to know
<a name="l-222"></a><span class="tm">20:00:51</span><span class="nk"> &lt;cdecker&gt;</span> Sounds like we got some homework to go through the DF spec :-)
<a name="l-223"></a><span class="tm">20:01:01</span><span class="nk"> &lt;niftynei&gt;</span> https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-January/002938.html
<a name="l-224"></a><span class="tm">20:01:20</span><span class="nk"> &lt;niftynei&gt;</span> lloyd's email ftr
<a name="l-225"></a><span class="tm">20:01:23</span><span class="nk"> &lt;niftynei&gt;</span> <span class="cmd">#link </span><span class="cmdline">https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-January/002938.html</span>
<a name="l-226"></a><span class="tm">20:01:39</span><span class="nk"> &lt;ariard&gt;</span> yeah i'll try to finish my review soon, some small recommendations around standardness in mind
<a name="l-227"></a><span class="tm">20:01:50</span><span class="nk"> &lt;t-bast&gt;</span> thanks for the link
<a name="l-228"></a><span class="tm">20:01:57</span><span class="nk"> &lt;niftynei&gt;</span> np! it's a great thread
<a name="l-229"></a><span class="tm">20:02:59</span><span class="nk"> &lt;niftynei&gt;</span> if there's nothing else, happy to cede the floor to the next topic :)
<a name="l-230"></a><span class="tm">20:03:14</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">niftynei:</span> so conclusion is that leaking balances or w/e via failed funding init attempts isn't that big of a deal in practice so no mitigations in current version?
<a name="l-231"></a><span class="tm">20:03:26</span><span class="nk"> &lt;cdecker&gt;</span> One thing we should point out is that the funding tx malleation can no longer happen with the dual-funding proposal 👍
<a name="l-232"></a><span class="tm">20:03:33</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">rusty:</span> wanna talk about offers :) ?
<a name="l-233"></a><span class="tm">20:03:41</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">ariard:</span> always!
<a name="l-234"></a><span class="tm">20:03:51</span><span class="nk"> &lt;cdecker&gt;</span> <span class="topic">#topic </span><span class="topicline">Long Term Updates: Offers</span>
<a name="l-235"></a><span class="tm">20:03:54</span><span class="nk"> &lt;ariard&gt;</span> you have the mic!
<a name="l-236"></a><span class="tm">20:03:57</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">cdecker:</span> isn't that the case rn? since we require segwit inputs, err well it's in the best interest of the funder to do that
<a name="l-237"></a><span class="tm">20:04:25</span><span class="nk"> &lt;ariard&gt;</span> we might need to require disclosure of witnessScript to avoid standardness malleability
<a name="l-238"></a><span class="tm">20:04:30</span><span class="nk"> &lt;cdecker&gt;</span> well in theory, but both eclair and c-lightning had users malleate their funding txs through RBF
<a name="l-239"></a><span class="tm">20:04:48</span><span class="nk"> &lt;roasbeef&gt;</span> ahhh yeh you can't rbf it, gotta cpfp it
<a name="l-240"></a><span class="tm">20:05:01</span><span class="nk"> &lt;roasbeef&gt;</span> we had ppl do that via electrum as well unfortunately when using psbt for funding
<a name="l-241"></a><span class="tm">20:05:38</span><span class="nk"> &lt;t-bast&gt;</span> that's exactly what happened to some of our users as well...that "bump fee" button in electrum was too tempting for them and we had no way of preventing them from doing it
<a name="l-242"></a><span class="tm">20:05:47</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">ariard:</span> if it confirms, it confirms tho right? assuming you're not doing zero conf
<a name="l-243"></a><span class="tm">20:05:57</span><span class="nk"> &lt;roasbeef&gt;</span> yeh we helped manually rescue a few instances of that in the past
<a name="l-244"></a><span class="tm">20:06:04</span><span class="nk"> &lt;niftynei&gt;</span> roasbeef, the conclusion is that you're already leaking your balances so having one other vector for it is something we can mitigate later
<a name="l-245"></a><span class="tm">20:06:28</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">roasbeef:</span> yeah it's more someone not liking your big routing node and preventing transactions propagation for a while
<a name="l-246"></a><span class="tm">20:06:34</span><span class="nk"> &lt;ariard&gt;</span> until you double-spend your own utxos
<a name="l-247"></a><span class="tm">20:06:51</span><span class="nk"> &lt;rusty&gt;</span> So there are three parts to offers: 1. onion messages, which are pretty simple to implement, 2. parsing and converting offers to invoices, and 3. actually implementing creation of offers and producing invoices.
<a name="l-248"></a><span class="tm">20:06:59</span><span class="nk"> &lt;ariard&gt;</span> that kind of risk should be considered if your dual-funded inputs aren't of equal value
<a name="l-249"></a><span class="tm">20:07:44</span><span class="nk"> &lt;rusty&gt;</span> Turns out, if you just want to pay an offer you can pretty much do on top of any existing implementation: you just need to connect directly to the offering node and ask for the invoice.  That's pretty dumb (from a privacy POV unless Tor), but it "works".
<a name="l-250"></a><span class="tm">20:08:03</span><span class="nk"> &lt;rusty&gt;</span> Ideally we get onion messages rolled out so this isn't required, but it'll be a fallback for a while.
<a name="l-251"></a><span class="tm">20:08:05</span><span class="nk"> &lt;roasbeef&gt;</span> so ln-url style basically?
<a name="l-252"></a><span class="tm">20:08:25</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> yeah, except a lightning connection instead of https.
<a name="l-253"></a><span class="tm">20:09:01</span><span class="nk"> &lt;roasbeef&gt;</span> I guess that could be rendezvoused in theory lol
<a name="l-254"></a><span class="tm">20:09:08</span><span class="nk"> &lt;roasbeef&gt;</span> also called a "proxy" :p
<a name="l-255"></a><span class="tm">20:09:11</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> yeah....
<a name="l-256"></a><span class="tm">20:09:23</span><span class="nk"> &lt;niftynei&gt;</span> <span class="hi">ariard:</span> more than one open in the same tx would mitigate it also
<a name="l-257"></a><span class="tm">20:09:45</span><span class="nk"> &lt;rusty&gt;</span> There are two spec changes I'm considering though.  1. remove the reply from the onion message format.  At the moment you can put a reply path in there, but you can also just put it in the actual message payload.  THis would simplify the spec even further, but means if they can't parse the message your SOL.
<a name="l-258"></a><span class="tm">20:09:59</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">niftynei:</span> can't parse ? can you explain further :)
<a name="l-259"></a><span class="tm">20:10:38</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">ariard:</span> you can't get a reply for a malformed/unsupported onion_message payload.
<a name="l-260"></a><span class="tm">20:10:39</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">niftynei:</span> let's talk about it on the pr
<a name="l-261"></a><span class="tm">20:11:17</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">rusty:</span> how did replies work before if you can't parse the message? presumably only if you can partially-parse it? or failed back via intermediate state?
<a name="l-262"></a><span class="tm">20:11:27</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">rusty:</span> sorry we're blurring subjects was a reply to niftynei
<a name="l-263"></a><span class="tm">20:11:50</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">BlueMatt:</span> layering.  The onion message itself has a TLV, one of which is the reply path.
<a name="l-264"></a><span class="tm">20:12:19</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">BlueMatt:</span> but turns out many payloads want to include a reply path themselves for other reasons.
<a name="l-265"></a><span class="tm">20:12:25</span><span class="nk"> &lt;BlueMatt&gt;</span> right, ok, so you'd have to have parsed the message message, just the message itself is bunk.
<a name="l-266"></a><span class="tm">20:12:33</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">BlueMatt:</span> yeah,or unsupported.
<a name="l-267"></a><span class="tm">20:13:17</span><span class="nk"> &lt;BlueMatt&gt;</span> right, ok. NAKs generally ~whatever for me, but, continue.
<a name="l-268"></a><span class="tm">20:13:53</span><span class="nk"> &lt;rusty&gt;</span> The other change is that I use the (merkle) hash of the invoice as the payment_secret.  This is dumb: we are falling back on the idea that the invoice is kept secret, which is a hack.
<a name="l-269"></a><span class="tm">20:14:47</span><span class="nk"> &lt;rusty&gt;</span> For offers, we *have* a payer_key: ideally we'd have a new field in the onion which was the signature using that key of the onion's mu-key (or something else which is tied to this specific HTLC onion).
<a name="l-270"></a><span class="tm">20:15:55</span><span class="nk"> &lt;t-bast&gt;</span> that's an interesting idea
<a name="l-271"></a><span class="tm">20:16:22</span><span class="nk"> &lt;rusty&gt;</span> The final thing is bolt12-bolt11 invoice compat to convert (at least the simple cases!) between the two.  THis means defining a mapping and including the sigs for the other style (bolt11 sigs are v. v. tied to the format, bolt12 are much saner).
<a name="l-272"></a><span class="tm">20:16:58</span><span class="nk"> &lt;BlueMatt&gt;</span> do we have to support mapping?
<a name="l-273"></a><span class="tm">20:17:10</span><span class="nk"> &lt;BlueMatt&gt;</span> is that just to provide wrappers for old nodes to send to new ones?
<a name="l-274"></a><span class="tm">20:17:14</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">BlueMatt:</span> no, it's just a bridge.
<a name="l-275"></a><span class="tm">20:17:27</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">BlueMatt:</span> yeah, it would let you gateway for simple offers.
<a name="l-276"></a><span class="tm">20:18:00</span><span class="nk"> &lt;BlueMatt&gt;</span> sounds like a lot of complexity we'd eventually remove, but, sure, making it optional, up to you
<a name="l-277"></a><span class="tm">20:18:03</span><span class="nk"> &lt;rusty&gt;</span> Any questions?  Especially of the stlye "um, what are you talking about?"
<a name="l-278"></a><span class="tm">20:18:23</span><span class="nk"> &lt;roasbeef&gt;</span> what's the payer key thing exactly? and what's it achieve?
<a name="l-279"></a><span class="tm">20:18:57</span><span class="nk"> &lt;roasbeef&gt;</span> i also don't get why a new invoice format is needed if the existing on can be extended, tho I'm all for getting rid of the weird 5 word byte stuff and uncessary usage of bech32 in the existing one
<a name="l-280"></a><span class="tm">20:19:30</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> it's a transient key given by the payer as part of the req for the actual invoice.  Allows recurrence privacy, refunds, proof-of-payer....
<a name="l-281"></a><span class="tm">20:19:49</span><span class="nk"> &lt;roasbeef&gt;</span> which is then *included* in the final invoice?
<a name="l-282"></a><span class="tm">20:19:53</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> yeah, I originally started extending bolt11 but hit those same....
<a name="l-283"></a><span class="tm">20:20:21</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> yeah: by design, everything you need is in the final invoice so you don't actually need to keep the offer if you didn't want to.
<a name="l-284"></a><span class="tm">20:20:54</span><span class="nk"> &lt;roasbeef&gt;</span> is a bridge in the other direction possible? so just giving them a bolt 11 invoice yet still being able to complete the from the pov of the "offer", thinking about wallet that have slow uptake of new features here
<a name="l-285"></a><span class="tm">20:21:12</span><span class="nk"> &lt;roasbeef&gt;</span> guessing yeh if there're no new tlv records added in the onion payload?
<a name="l-286"></a><span class="tm">20:22:11</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> yeah, but it's so much easier for them to parse bolt12 than bolt11.  Could do it though.
<a name="l-287"></a><span class="tm">20:23:19</span><span class="nk"> &lt;t-bast&gt;</span> how much work do you estimate it takes to get a prototype running from scratch, if an implementation wanted to start from nothing and prototype it by going through the spec PR?
<a name="l-288"></a><span class="tm">20:23:50</span><span class="nk"> &lt;rusty&gt;</span> (Heh, I guess he didn't want to hear the answer!)
<a name="l-289"></a><span class="tm">20:24:15</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> ... and that's how simple it is!  Any questions?
<a name="l-290"></a><span class="tm">20:24:20</span><span class="nk"> &lt;roasbeef&gt;</span> lol
<a name="l-291"></a><span class="tm">20:24:24</span><span class="nk"> &lt;roasbeef&gt;</span> yeh seems feasible
<a name="l-292"></a><span class="tm">20:24:26</span><span class="nk"> &lt;t-bast&gt;</span> sorry I got dc-ed and missed that!
<a name="l-293"></a><span class="tm">20:24:26</span><span class="nk"> &lt;ariard&gt;</span> Or maybe he just get started
<a name="l-294"></a><span class="tm">20:24:33</span><span class="nk"> &lt;roasbeef&gt;</span> actually I just finsihed it
<a name="l-295"></a><span class="tm">20:24:40</span><span class="nk"> &lt;t-bast&gt;</span> looks like even my IRC client doesn't want us to work on offers xD
<a name="l-296"></a><span class="tm">20:24:58</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> was joking.  Parsing offers is trivial, it's a de-bech32 then it's lightning wire format.
<a name="l-297"></a><span class="tm">20:25:49</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> handling bolt11 vs bolt12 invoices was simple too, they're very distinct.  The actual onion and HTLC is the same.
<a name="l-298"></a><span class="tm">20:25:58</span><span class="nk"> &lt;t-bast&gt;</span> LOL just saw the logs from http://gnusha.org/lightning-dev/
<a name="l-299"></a><span class="tm">20:27:33</span><span class="nk"> &lt;t-bast&gt;</span> I'm mostly thinking that understanding and implementation the tree construction may be the part where you scratch your head a bit, right?
<a name="l-300"></a><span class="tm">20:27:57</span><span class="nk"> &lt;roasbeef&gt;</span> what's the purpose of the tree thing? basically picking off where we left off re the "description hash" in bolt 11?
<a name="l-301"></a><span class="tm">20:28:25</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> actually issuing offers is a command to do so; that's a pretty big API.  The code to receive the onion message requesting an offer, and generating the invoice associated is straightforward, but there are also "send0me-money" offers, which have atomicity requirements: you only want to send them the payment once.
<a name="l-302"></a><span class="tm">20:29:32</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> it's mainly for signing (though we use it as an "id" as well); it's a bit more complex than a linear hash, but it allows much more neatly for omitting signature field(s).
<a name="l-303"></a><span class="tm">20:29:45</span><span class="nk"> &lt;rusty&gt;</span> (i.e. merkle calc omits any TLVs 250-1000 incl).
<a name="l-304"></a><span class="tm">20:30:18</span><span class="nk"> &lt;rusty&gt;</span> Has nice side effect that you can (handwave, future) provide proofs without revealing entire thing.
<a name="l-305"></a><span class="tm">20:32:45</span><span class="nk"> &lt;rusty&gt;</span> TBH, most of the work was not implementing, but exploring the space and adding requirements.  Things like recurrence and offer -&gt; invoice malleability (i.e. offer has a description, invoice returned had a different description, but also amounts, etc)
<a name="l-306"></a><span class="tm">20:32:51</span><span class="nk"> &lt;rusty&gt;</span> Any other questions?
<a name="l-307"></a><span class="tm">20:33:27</span><span class="nk"> &lt;ariard&gt;</span> *tagging this as a "good first issue" in RL
<a name="l-308"></a><span class="tm">20:33:28</span><span class="nk"> &lt;t-bast&gt;</span> Nope, looks interesting, I'm hoping we'll get time to work on this soon :)
<a name="l-309"></a><span class="tm">20:34:15</span><span class="nk"> &lt;rusty&gt;</span> Yeah, I'm excited to get other implementer feedback.  Both on text of spec, and all the random details where I just flipped a coin....
<a name="l-310"></a><span class="tm">20:34:31</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">ariard:</span> you have the chair again :)
<a name="l-311"></a><span class="tm">20:34:51</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">rusty:</span> thanks for the presentation :)
<a name="l-312"></a><span class="tm">20:35:20</span><span class="nk"> &lt;ariard&gt;</span> folks wants to keep the meeting with another topic?
<a name="l-313"></a><span class="tm">20:35:44</span><span class="nk"> &lt;cdecker&gt;</span> I think I'll have to drop off pretty soon
<a name="l-314"></a><span class="tm">20:35:45</span><span class="nk"> &lt;roasbeef&gt;</span> g2g on my end
<a name="l-315"></a><span class="tm">20:35:53</span><span class="nk"> &lt;ariard&gt;</span> okay let's end there
<a name="l-316"></a><span class="tm">20:35:58</span><span class="nk"> &lt;t-bast&gt;</span> I'll drop off as well
<a name="l-317"></a><span class="tm">20:36:01</span><span class="nk"> &lt;ariard&gt;</span> <span class="cmd">#endmeeting</span><span class="cmdline"></span></pre>
</body></html>
