<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<title>#lightning-dev log</title>
<style type="text/css">
/* For the .log.html */
pre { /*line-height: 125%;*/
      white-space: pre-wrap; }
body { background: #f0f0f0; }

body .tm  { color: #007020 }                      /* time */
body .nk  { color: #062873; font-weight: bold }   /* nick, regular */
body .nka { color: #007020; font-weight: bold }  /* action nick */
body .ac  { color: #00A000 }                      /* action line */
body .hi  { color: #4070a0 }                 /* hilights */
/* Things to make particular MeetBot commands stick out */
body .topic     { color: #007020; font-weight: bold }
body .topicline { color: #000080; font-weight: bold }
body .cmd       { color: #007020; font-weight: bold }
body .cmdline  { font-weight: bold }

</style>
</head>

<body>
<pre><a name="l-1"></a><span class="tm">20:17:13</span><span class="nk"> &lt;t-bast&gt;</span> <span class="cmd">#startmeeting </span><span class="cmdline">LN Spec Meeting</span>
<a name="l-2"></a><span class="tm">20:17:13</span><span class="nk"> &lt;lndev-bot&gt;</span> Meeting started Mon Apr 26 20:17:13 2021 UTC and is due to finish in 60 minutes.  The chair is t-bast. Information about MeetBot at http://wiki.debian.org/MeetBot.
<a name="l-3"></a><span class="tm">20:17:13</span><span class="nk"> &lt;lndev-bot&gt;</span> Useful Commands: #action #agreed #help #info #idea #link #topic #startvote.
<a name="l-4"></a><span class="tm">20:17:13</span><span class="nk"> &lt;lndev-bot&gt;</span> The meeting name has been set to 'ln_spec_meeting'
<a name="l-5"></a><span class="tm">20:17:31</span><span class="nk"> &lt;cdecker&gt;</span> Ah there you go, it's not working on the VPS but from home it is...
<a name="l-6"></a><span class="tm">20:17:37</span><span class="nk"> &lt;t-bast&gt;</span> <span class="topic">#topic </span><span class="topicline">Funding Timeout Recovery</span>
<a name="l-7"></a><span class="tm">20:17:37</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> I'll have to do a mechnical check on 852, but looks good. (repaste from before meeting start, for posterity)
<a name="l-8"></a><span class="tm">20:18:01</span><span class="nk"> &lt;cdecker&gt;</span> Ok, as promised I wrote up the keyolo variant, but it feels "wrong"
<a name="l-9"></a><span class="tm">20:18:02</span><span class="nk"> &lt;t-bast&gt;</span> thanks rusty! Let's move to the other items, once we have interop on that one we'll just merge
<a name="l-10"></a><span class="tm">20:18:14</span><span class="nk"> &lt;cdecker&gt;</span> PR #866 is the competing one btw
<a name="l-11"></a><span class="tm">20:18:16</span><span class="nk"> &lt;t-bast&gt;</span> <span class="cmd">#link </span><span class="cmdline">https://github.com/lightningnetwork/lightning-rfc/issues/864</span>
<a name="l-12"></a><span class="tm">20:18:23</span><span class="nk"> &lt;t-bast&gt;</span> <span class="cmd">#https://github.com/lightningnetwork/lightning-rfc/issues/866</span><span class="cmdline"></span>
<a name="l-13"></a><span class="tm">20:18:45</span><span class="nk"> &lt;t-bast&gt;</span> <span class="cmd">#link </span><span class="cmdline">https://github.com/lightningnetwork/lightning-rfc/pull/866</span>
<a name="l-14"></a><span class="tm">20:18:48</span><span class="nk"> &lt;cdecker&gt;</span> Let's keep tradeoff discussions to #854 to keep them localized and wording suggestions can go to the respective PR
<a name="l-15"></a><span class="tm">20:18:52</span><span class="nk"> &lt;t-bast&gt;</span> <span class="cmd">#link </span><span class="cmdline">https://github.com/lightningnetwork/lightning-rfc/pull/854</span>
<a name="l-16"></a><span class="tm">20:19:42</span><span class="nk"> &lt;rusty&gt;</span> I like 866, but it's weird.  We can't extend the error message, so we need a new msg anyway.  I don't think the discussion of malleability applies, since "here's the key, do what you want" seems sufficient to cover that?
<a name="l-17"></a><span class="tm">20:20:25</span><span class="nk"> &lt;cdecker&gt;</span> Would have been nice to add a TLV to the error instead
<a name="l-18"></a><span class="tm">20:20:56</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">cdecker:</span> yeh not a fan of just sending private keys over the wire to peers as I commented on the OG PR....
<a name="l-19"></a><span class="tm">20:21:29</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">cdecker:</span> another advantage of OG proposal is fundee can still add a balance in the closing tx
<a name="l-20"></a><span class="tm">20:21:40</span><span class="nk"> &lt;cdecker&gt;</span> Yep, same here, it should be rare, so I don't weigh the on-chain footprint too much either
<a name="l-21"></a><span class="tm">20:21:43</span><span class="nk"> &lt;ariard&gt;</span> like if you negotiated a push_msat out-of-band or already paid for it
<a name="l-22"></a><span class="tm">20:22:22</span><span class="nk"> &lt;cdecker&gt;</span> <span class="hi">ariard:</span> wouldn't that require a sighash_single and require the matching output to be the fundee's?
<a name="l-23"></a><span class="tm">20:22:54</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">cdecker:</span> for sure it would require single, lastest of proposal is sighash_none?
<a name="l-24"></a><span class="tm">20:22:56</span><span class="nk"> &lt;cdecker&gt;</span> That'd allow the fundee to force an output to him as compensation
<a name="l-25"></a><span class="tm">20:23:13</span><span class="nk"> &lt;cdecker&gt;</span> Yep, sighash_none to impose as little restrictions as possible
<a name="l-26"></a><span class="tm">20:23:22</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">cdecker:</span> I'm not sure what you mean "creates a new foot-gun" - if you dont have a way of storing the latest state reliably, you are already in face-gun territory, this isnt new there.
<a name="l-27"></a><span class="tm">20:23:30</span><span class="nk"> &lt;cdecker&gt;</span> Not a fan of complicating what is pretty much a gentlemans agreement
<a name="l-28"></a><span class="tm">20:23:40</span><span class="nk"> &lt;BlueMatt&gt;</span> there was also discussion of this in the context of taproot
<a name="l-29"></a><span class="tm">20:23:44</span><span class="nk"> &lt;ariard&gt;</span> and how do that make sense for dual-funded channel? wouldn't OG proposal makes more sense
<a name="l-30"></a><span class="tm">20:23:52</span><span class="nk"> &lt;BlueMatt&gt;</span> where sighash_single isnt just a trivial change, its materially more expensive
<a name="l-31"></a><span class="tm">20:24:01</span><span class="nk"> &lt;cdecker&gt;</span> Hm? Which footgun comment are you referring to? Made a couple of them in this context :-)
<a name="l-32"></a><span class="tm">20:24:17</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">cdecker:</span> I was referring to the quote you left on the non-yolo variant describing the difference
<a name="l-33"></a><span class="tm">20:24:42</span><span class="nk"> &lt;cdecker&gt;</span> dual-funded channels are not impacted by this since the funding needs to be collaboratively agreed on anyway, and RBF can't be done without collaboration
<a name="l-34"></a><span class="tm">20:24:46</span><span class="nk"> &lt;roasbeef&gt;</span> taproot is still a ways away, and it'll be a pretty massive overhaul, so imo shouldn't affect what we do in the short term
<a name="l-35"></a><span class="tm">20:25:15</span><span class="nk"> &lt;roasbeef&gt;</span> don't think I can bring myself to add in code that dumps a private key over the wire....
<a name="l-36"></a><span class="tm">20:25:19</span><span class="nk"> &lt;cdecker&gt;</span> That was roasbeef's comment talking about a footgun :-)
<a name="l-37"></a><span class="tm">20:25:25</span><span class="nk"> &lt;BlueMatt&gt;</span> sure, but if we're close to the fence on a proposal, it seems like a worthwhile thing to shift us one way or another :)
<a name="l-38"></a><span class="tm">20:25:44</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">cdecker:</span> sure but we assume the funding has confirmed here and try to avoid feerate penalty on commitment
<a name="l-39"></a><span class="tm">20:25:51</span><span class="nk"> &lt;roasbeef&gt;</span> how would ppl even expose this on the node level? does the responder have to opt in to agree to send their key?
<a name="l-40"></a><span class="tm">20:26:04</span><span class="nk"> &lt;roasbeef&gt;</span> just seems really error prone imo
<a name="l-41"></a><span class="tm">20:26:16</span><span class="nk"> &lt;roasbeef&gt;</span> inb4 some reddit scam or something
<a name="l-42"></a><span class="tm">20:26:38</span><span class="nk"> &lt;cdecker&gt;</span> Nah, it's a throwaway key that should not leak info (in theory when derived in a hardened way), but I also prefer #854 (non-keyolo)
<a name="l-43"></a><span class="tm">20:26:46</span><span class="nk"> &lt;BlueMatt&gt;</span> huh? hopefully the node never exposes some config option to let users manually do this?
<a name="l-44"></a><span class="tm">20:27:02</span><span class="nk"> &lt;ariard&gt;</span> and if you have a hardware signer? quite uncomfortable to have a policy exporting private key
<a name="l-45"></a><span class="tm">20:27:04</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">cdecker:</span> throw away key? I read it as the funding private key rn
<a name="l-46"></a><span class="tm">20:27:16</span><span class="nk"> &lt;roasbeef&gt;</span> and also what if you can't even get a private key from a node easily?
<a name="l-47"></a><span class="tm">20:27:20</span><span class="nk"> &lt;cdecker&gt;</span> Yeah, it's just "1) forget channel but keep stub, 2) on reconnect tell the peer so they can recover"
<a name="l-48"></a><span class="tm">20:27:23</span><span class="nk"> &lt;BlueMatt&gt;</span> in both cases you have to make sure you make sure the channel closure is committed to disk before you expose anything, I dont think thats very different
<a name="l-49"></a><span class="tm">20:27:40</span><span class="nk"> &lt;BlueMatt&gt;</span> alright, well so far it sounds like everyone disagrees with me. I'm happy to be overruled :)
<a name="l-50"></a><span class="tm">20:27:49</span><span class="nk"> &lt;cdecker&gt;</span> <span class="hi">roasbeef:</span> yes, but its a funding_privkey specifically generated for that channel, if you're not using the channel there's no need to keep it private
<a name="l-51"></a><span class="tm">20:28:06</span><span class="nk"> &lt;roasbeef&gt;</span> yeh but we don't really have any spec level requirements on how that key is generated cdecker
<a name="l-52"></a><span class="tm">20:28:31</span><span class="nk"> &lt;cdecker&gt;</span> <span class="hi">BlueMatt:</span> yep, that was my comment to roasbeef's footgun: forgotten, persisted, marked as inactive, and only then reveal the privkey
<a name="l-53"></a><span class="tm">20:28:37</span><span class="nk"> &lt;roasbeef&gt;</span> so if you assume the worst case, bad things could happen, and also we'd essentially be requiring hot funding keys forever on the spec levle
<a name="l-54"></a><span class="tm">20:28:53</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">BlueMatt:</span> well with taproot you can add a tapscript to sign to be used especially with sighash_single, but you might loose the feerate saving due to longuer merkle branch...
<a name="l-55"></a><span class="tm">20:29:03</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">cdecker:</span> right, i think my point is more broadly the foot-gun quesiton here is no different between the two proposals, and it is further no different than really every other "you didnt persist properly" foot gun in lightning today
<a name="l-56"></a><span class="tm">20:29:13</span><span class="nk"> &lt;cdecker&gt;</span> Just to be clear, the keyolo is the result of 4 weeks ago's discussion, I'm not a fan myself, but wanted to give the option
<a name="l-57"></a><span class="tm">20:29:39</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">ariard:</span> right, my point was you cannot do the joined signature. thanks for clarifying :)
<a name="l-58"></a><span class="tm">20:29:49</span><span class="nk"> &lt;cdecker&gt;</span> Also because it seemed overwhelmingly everyone wanted to go keyolo instead xD
<a name="l-59"></a><span class="tm">20:29:56</span><span class="nk"> &lt;t-bast&gt;</span> I think the argument of not having easy access to the funding private key because it's delegated to another component is a reasonable argument to prefer #854 over #866
<a name="l-60"></a><span class="tm">20:30:32</span><span class="nk"> &lt;cdecker&gt;</span> Also it doesn't introduce the belated requirement of hardened derivation for the funding_privkey
<a name="l-61"></a><span class="tm">20:30:34</span><span class="nk"> &lt;t-bast&gt;</span> I wanted to go keyolo for simplicity's sake, but I understand that it's actually harder for some implementations than non-keyolo
<a name="l-62"></a><span class="tm">20:30:45</span><span class="nk"> &lt;rusty&gt;</span> I somewhat share roasbeef's concern: now our HSM gives out keys, which makes me uncomfortable.  OTOH, it's definitely simpler.
<a name="l-63"></a><span class="tm">20:31:16</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">t-bast:</span> I mean signing sighash-none is really not a lot different from just exposing the priv key
<a name="l-64"></a><span class="tm">20:31:28</span><span class="nk"> &lt;BlueMatt&gt;</span> hsm should have similar requirements for both, honestly
<a name="l-65"></a><span class="tm">20:31:31</span><span class="nk"> &lt;cdecker&gt;</span> Good point rusty, it'd be state to keep in our hsmd to remember that we gave out the key, and that we mustn't sign commitment txs for that key anymore
<a name="l-66"></a><span class="tm">20:31:52</span><span class="nk"> &lt;cdecker&gt;</span> ... which is also true for #854, damn
<a name="l-67"></a><span class="tm">20:32:55</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">BlueMatt:</span> true, sighash_none is something HSMs wouldn't lightly sign...
<a name="l-68"></a><span class="tm">20:32:56</span><span class="nk"> &lt;ariard&gt;</span> well you can delete the key once sent, but quid of network disconnection at the same time?
<a name="l-69"></a><span class="tm">20:33:14</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">ariard:</span> yea, preferably not, though I guess its best-effort anyway, soooooooo
<a name="l-70"></a><span class="tm">20:33:18</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">t-bast:</span> depends on the hsm really there's levels, first level is just it can do secp signing before even doing sighash stuff, etc
<a name="l-71"></a><span class="tm">20:33:45</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">ariard:</span> yea, i think thats not really a bad idea, really. I mean it sucks cause its not reliable, but the funder shouldnt be relying on this to begin with
<a name="l-72"></a><span class="tm">20:33:46</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">roasbeef:</span> an HSM that doesn't do any kind of validation is a false sense of security imho
<a name="l-73"></a><span class="tm">20:33:58</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">t-bast:</span> well you start w/ just segregation there go from there
<a name="l-74"></a><span class="tm">20:34:20</span><span class="nk"> &lt;roasbeef&gt;</span> it isn't a binary thing
<a name="l-75"></a><span class="tm">20:34:21</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">BlueMatt:</span> you might cache the message until ack from counterparty but have deleted the state
<a name="l-76"></a><span class="tm">20:34:37</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">ariard:</span> there is no ack? or do you mean tcp-ack?
<a name="l-77"></a><span class="tm">20:34:39</span><span class="nk"> &lt;cdecker&gt;</span> Yep, it's a simple proposal, must not work all the time (gentleperson's agreement remember) and we definitely don't want to get incentives such as fundee payoffs into the mix
<a name="l-78"></a><span class="tm">20:34:58</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">BlueMatt:</span> i mean lightning message level ack, tcp would be such a layer violation
<a name="l-79"></a><span class="tm">20:35:06</span><span class="nk"> &lt;ariard&gt;</span> and you might not run lightning on tcp
<a name="l-80"></a><span class="tm">20:35:17</span><span class="nk"> &lt;cdecker&gt;</span> The stubs can be removed after a while btw, if the peer doesn't reconnect in 2 weeks there's no need to keep them around imho
<a name="l-81"></a><span class="tm">20:35:20</span><span class="nk"> &lt;t-bast&gt;</span> I agree with cdecker, this should still be an exceptional case and we shouldn't over-engineer it
<a name="l-82"></a><span class="tm">20:35:48</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">ariard:</span> ok, so you mean we should add an ack. i guess, but, like, then what if the funder doesnt send one, then its the same as having no ack :)
<a name="l-83"></a><span class="tm">20:36:19</span><span class="nk"> &lt;rusty&gt;</span> I think we can do simpler than 854.  1. extend reestablish to include the outpoint and amount for the commit tx. 2. have a reply which signs that for any stub, aborted channel.  This means it doesn't even need to remember anything except the key, peer id and channel id, and covers the "I accidentally RBFed the commit tx" case.
<a name="l-84"></a><span class="tm">20:36:29</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">BlueMatt:</span> let's say timeout on your cache? but yeah sounds over-engineering
<a name="l-85"></a><span class="tm">20:37:10</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">rusty:</span> presumably you mean with sighash_none? or we'd have to include the output as well.
<a name="l-86"></a><span class="tm">20:37:41</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">BlueMatt:</span> yeah, if you want sighash_single you would have to provide output.  Or normal sig and provide entire tx, but that's getting a bit hairy maybe.
<a name="l-87"></a><span class="tm">20:38:24</span><span class="nk"> &lt;cdecker&gt;</span> Let's start with sighash_none, we can always add complexity later (... never)
<a name="l-88"></a><span class="tm">20:38:39</span><span class="nk"> &lt;roasbeef&gt;</span> kek
<a name="l-89"></a><span class="tm">20:38:52</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">cdecker:</span> but can't someone else steal the sighash none?  Hmm, I guess it needs both sigs, so no...
<a name="l-90"></a><span class="tm">20:38:55</span><span class="nk"> &lt;BlueMatt&gt;</span> dont you mean remove complexity by sending the privkey? *ducks*
<a name="l-91"></a><span class="tm">20:39:01</span><span class="nk"> &lt;BlueMatt&gt;</span> but, sure, I'm down for whatever
<a name="l-92"></a><span class="tm">20:39:24</span><span class="nk"> &lt;ariard&gt;</span> if you have to agree on output amount you migh need yet another negotiation mechanism
<a name="l-93"></a><span class="tm">20:39:43</span><span class="nk"> &lt;BlueMatt&gt;</span> you shouldnt need to agree - if you've closed the channel, you've closed it
<a name="l-94"></a><span class="tm">20:39:54</span><span class="nk"> &lt;t-bast&gt;</span> I don't follow why it would be simpler than #854
<a name="l-95"></a><span class="tm">20:39:56</span><span class="nk"> &lt;BlueMatt&gt;</span> sign anything the counterparty wants, if its wrong, full nodes will reject it
<a name="l-96"></a><span class="tm">20:40:11</span><span class="nk"> &lt;ariard&gt;</span> in the hypothesis we have also sighash_single and the fundee would propose a cooperation payoff
<a name="l-97"></a><span class="tm">20:40:51</span><span class="nk"> &lt;BlueMatt&gt;</span> yea, this is more "nodes will do this by default cause its nice, and most people dont modify their nodes because its hard" not "game theoretically secure and ideal"
<a name="l-98"></a><span class="tm">20:41:07</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">BlueMatt:</span> and of course "it's worked so far" :)
<a name="l-99"></a><span class="tm">20:41:37</span><span class="nk"> &lt;BlueMatt&gt;</span> right, works nearly perfectly in practice, works none of the time in theory :)
<a name="l-100"></a><span class="tm">20:41:55</span><span class="nk"> &lt;cdecker&gt;</span> <span class="hi">ariard:</span> payoff for the fundee seems out of scope, that's far more negotiation than I'm willing to add for such a corner case
<a name="l-101"></a><span class="tm">20:42:32</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">cdecker:</span> i far agree there, i was just thinking in a future where lightning is so efficient than people to price their missed opportunities for lack of funding confs
<a name="l-102"></a><span class="tm">20:42:52</span><span class="nk"> &lt;roasbeef&gt;</span> does anything deployed rn even use sighash_none? we're about to get soooo many cool points
<a name="l-103"></a><span class="tm">20:43:11</span><span class="nk"> &lt;t-bast&gt;</span> xD
<a name="l-104"></a><span class="tm">20:43:13</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">roasbeef:</span> lol, great point!
<a name="l-105"></a><span class="tm">20:43:25</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">roasbeef:</span> well you need to combine it with sighash_noinput to be a cool kid
<a name="l-106"></a><span class="tm">20:44:05</span><span class="nk"> &lt;unixb0y&gt;</span> Hey guys any news about Offers in lnd? :)
<a name="l-107"></a><span class="tm">20:44:05</span><span class="nk"> &lt;rusty&gt;</span> "I don't usually sign random transactions, but when I do it's with SIGHASH_NONE".
<a name="l-108"></a><span class="tm">20:44:11</span><span class="nk"> &lt;cdecker&gt;</span> That signature would sign pretty much the timelock and that's it xD
<a name="l-109"></a><span class="tm">20:44:24</span><span class="nk"> &lt;t-bast&gt;</span> Shall we conclude that we're leaning more towards #854?
<a name="l-110"></a><span class="tm">20:44:52</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">rusty:</span> LOL
<a name="l-111"></a><span class="tm">20:45:20</span><span class="nk"> &lt;cdecker&gt;</span> Sounds like we pretty much agree that #854 is a bit more restrictive than #866 and we can always expand based on later experience if needed
<a name="l-112"></a><span class="tm">20:45:25</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">t-bast:</span> ack.  More on issue?
<a name="l-113"></a><span class="tm">20:45:30</span><span class="nk"> &lt;cdecker&gt;</span> sgtm
<a name="l-114"></a><span class="tm">20:46:09</span><span class="nk"> &lt;t-bast&gt;</span> <span class="cmd">#action </span><span class="cmdline">Finalize details of 854 on PR</span>
<a name="l-115"></a><span class="tm">20:46:20</span><span class="nk"> &lt;t-bast&gt;</span> <span class="topic">#topic </span><span class="topicline">Deterministic points and splicing</span>
<a name="l-116"></a><span class="tm">20:46:30</span><span class="nk"> &lt;t-bast&gt;</span> <span class="cmd">#link </span><span class="cmdline">https://github.com/lightningnetwork/lightning-rfc/pull/862</span>
<a name="l-117"></a><span class="tm">20:46:34</span><span class="nk"> &lt;t-bast&gt;</span> <span class="cmd">#link </span><span class="cmdline">https://github.com/lightningnetwork/lightning-rfc/pull/863</span>
<a name="l-118"></a><span class="tm">20:46:41</span><span class="nk"> &lt;t-bast&gt;</span> I feel those two go together
<a name="l-119"></a><span class="tm">20:46:49</span><span class="nk"> &lt;rusty&gt;</span> OK, so before we get too far into this: I'm on the fence.
<a name="l-120"></a><span class="tm">20:47:08</span><span class="nk"> &lt;cdecker&gt;</span> How's the view?
<a name="l-121"></a><span class="tm">20:47:12</span><span class="nk"> &lt;roasbeef&gt;</span> interesting...so no more randomization?
<a name="l-122"></a><span class="tm">20:47:18 </span><span class="nka">* roasbeef</span> <span class="ac">looks at the commit</span>
<a name="l-123"></a><span class="tm">20:47:29</span><span class="nk"> &lt;BlueMatt&gt;</span> so one question i have is what about cases where you may want some keys derived from different things - eg payment_point maybe you want from an offline seed but the other keys maybe from an online one?
<a name="l-124"></a><span class="tm">20:47:30</span><span class="nk"> &lt;roasbeef&gt;</span> oh this is the sequence number for pubkeys thing?
<a name="l-125"></a><span class="tm">20:48:04</span><span class="nk"> &lt;rusty&gt;</span> The reason is that deterministic points mean that one channel is not really isolated from another any more, since the keys are now reversibly derived from the node id.  So if you accidentally give away one key, you lose the farm.  This was not true before.
<a name="l-126"></a><span class="tm">20:48:06</span><span class="nk"> &lt;roasbeef&gt;</span> how would ppl handle the new state requirement in practice? so like clear node, retain seed, re-use seed for new node situation
<a name="l-127"></a><span class="tm">20:48:19</span><span class="nk"> &lt;roasbeef&gt;</span> iirc in the past didn't CL remove something like this from the funding key derivation rusty ?
<a name="l-128"></a><span class="tm">20:48:22</span><span class="nk"> &lt;cdecker&gt;</span> Ah lol, if we get #862 then #866 is out of the question anyway, since we can't generate hardened keys using a generation
<a name="l-129"></a><span class="tm">20:49:16</span><span class="nk"> &lt;rusty&gt;</span> But OTOH, being able to sniff out your own channels from raw blockchain data is pretty damn neat on paper.
<a name="l-130"></a><span class="tm">20:50:06</span><span class="nk"> &lt;roasbeef&gt;</span> something something OP_RETURN....I think electrum does this in practice now/
<a name="l-131"></a><span class="tm">20:50:07</span><span class="nk"> &lt;BlueMatt&gt;</span> * and knowing *who* you had a channel with, correct?
<a name="l-132"></a><span class="tm">20:50:08</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> not that I recall: we used to hand the "per channel" keys across to the (per-peer) daemon, but then reverted to keeping them in the HSM.  Both are reasonable strategies.
<a name="l-133"></a><span class="tm">20:50:10</span><span class="nk"> &lt;roasbeef&gt;</span> ?
<a name="l-134"></a><span class="tm">20:50:36</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">BlueMatt:</span> you brute force from known nodes, plus anyone who connects to you.
<a name="l-135"></a><span class="tm">20:50:42</span><span class="nk"> &lt;BlueMatt&gt;</span> right, ok
<a name="l-136"></a><span class="tm">20:50:43</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">rusty:</span> iirc was something a sequence number per node pubkey to derive pubkeys or something, could be remembering something else...
<a name="l-137"></a><span class="tm">20:51:07</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> yeah, we use the db id (which only rachets forward).
<a name="l-138"></a><span class="tm">20:51:31</span><span class="nk"> &lt;rusty&gt;</span> So the scheme gets weaker since you need a counter of some kind, and now you get gap issues anyway.
<a name="l-139"></a><span class="tm">20:51:53</span><span class="nk"> &lt;t-bast&gt;</span> Can't you at least scope the link between key per-node? To ensure that if you give away one key, only all channels to that node are at risk, and not channels to other nodes?
<a name="l-140"></a><span class="tm">20:51:55</span><span class="nk"> &lt;BlueMatt&gt;</span> any response to my initial question?
<a name="l-141"></a><span class="tm">20:52:10</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">rusty:</span> doesn't this still require you to keep track of who the other node is?
<a name="l-142"></a><span class="tm">20:52:14</span><span class="nk"> &lt;BlueMatt&gt;</span> I do think that at least being able to generate payment-point in a different way is very useful.
<a name="l-143"></a><span class="tm">20:52:16</span><span class="nk"> &lt;BlueMatt&gt;</span> probably others
<a name="l-144"></a><span class="tm">20:52:40</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">BlueMatt:</span> IIUC this PR would make this scenario impossible...?
<a name="l-145"></a><span class="tm">20:52:48</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> you brute force from the public gossip + anyone who (re-)connects to you.
<a name="l-146"></a><span class="tm">20:52:50</span><span class="nk"> &lt;roasbeef&gt;</span> what if they get pruned as being a zombie from teh channel graph or something, not sure if y'all keep around the extra nodes there
<a name="l-147"></a><span class="tm">20:53:27</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">t-bast:</span> right, IIUC the same - hence why I bring it up :). may be there we could separate "maybe we want that separate" from "nah, probably not"?
<a name="l-148"></a><span class="tm">20:53:42</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">BlueMatt:</span> you keep payment_basepoint for that reason.
<a name="l-149"></a><span class="tm">20:53:54</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> yeah, best-effort, handwave something.
<a name="l-150"></a><span class="tm">20:54:34</span><span class="nk"> &lt;BlueMatt&gt;</span> hmmm, ok. there's probably some other keys that would be good to split out, I'd think.
<a name="l-151"></a><span class="tm">20:54:41</span><span class="nk"> &lt;rusty&gt;</span> So I think personally that the "secret backup blob stashed with peer and re-served on every reconnect" probably covers this and more.  And it's easier to implement.
<a name="l-152"></a><span class="tm">20:54:54</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">right:</span> `the payment basepoint is supplied directly` at the very end of the PR
<a name="l-153"></a><span class="tm">20:55:30</span><span class="nk"> &lt;ariard&gt;</span> you might traverse the transaction logs with filters of well-scored routing nodes first
<a name="l-154"></a><span class="tm">20:56:32</span><span class="nk"> &lt;t-bast&gt;</span> re my earlier question, I got to the `point derivation` part of the PR, so it seems that my question was moot, there's no connection between keys for channels with a different node
<a name="l-155"></a><span class="tm">20:56:34</span><span class="nk"> &lt;BlueMatt&gt;</span> yea, I'm definitely -0.01 here - I doubt we'll ever implement the chain-scanning stuff, if only because its a whole new api for it, and I could see it restricting what we can do going forward with different keys in different places/security models
<a name="l-156"></a><span class="tm">20:56:37</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">t-bast:</span> doesn't eclair do the encrypted blob storag ething now for phoenix clients?
<a name="l-157"></a><span class="tm">20:56:50</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">t-bast:</span> oh, wait, what?
<a name="l-158"></a><span class="tm">20:56:58</span><span class="nk"> &lt;BlueMatt&gt;</span> so its only the funding key thats derived consistently?
<a name="l-159"></a><span class="tm">20:57:08</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">rusty:</span> rather than mandate it couldn't it be a funding modifier? so you include the key as normal, but then specify that's how it ws generated
<a name="l-160"></a><span class="tm">20:57:11</span><span class="nk"> &lt;BlueMatt&gt;</span> I totally misunderstood that, and I thought I skimmed the mailing list post :/
<a name="l-161"></a><span class="tm">20:57:12</span><span class="nk"> &lt;t-bast&gt;</span> <span class="hi">roasbeef:</span> yes we're doing that
<a name="l-162"></a><span class="tm">20:57:14</span><span class="nk"> &lt;roasbeef&gt;</span> I think it's funding, htlc, payment base point
<a name="l-163"></a><span class="tm">20:57:19</span><span class="nk"> &lt;roasbeef&gt;</span> 4. The `funding_pubkey` is defined as the `node_id` + G*T(`funding`).
<a name="l-164"></a><span class="tm">20:57:22</span><span class="nk"> &lt;roasbeef&gt;</span> 5. The `delayed_payment_basepoint` is defined as `node_id` + G*T(`delayed_payment`).
<a name="l-165"></a><span class="tm">20:57:26</span><span class="nk"> &lt;roasbeef&gt;</span> 6. The `htlc_basepoint` is defined as the `node_id` + G*T(`htlc`).
<a name="l-166"></a><span class="tm">20:57:47</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> yeah, but it's really only useful if everyone does it, so I short-circuited.  But I was young and optimistic when I wrote that proposal...
<a name="l-167"></a><span class="tm">20:57:48</span><span class="nk"> &lt;BlueMatt&gt;</span> right, ok, so I'm not crazy. I think at least delayed_payment_basepoint may want to be on a different device
<a name="l-168"></a><span class="tm">20:58:25</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">rusty:</span> you as node could only open chans to nodes that use the deterministic generation possibly
<a name="l-169"></a><span class="tm">20:58:33</span><span class="nk"> &lt;ariard&gt;</span> well you might announce a derivation policy like another point for delayed_payment_basepoint
<a name="l-170"></a><span class="tm">20:58:40</span><span class="nk"> &lt;ariard&gt;</span> but it will more work for your counterparty
<a name="l-171"></a><span class="tm">20:59:33</span><span class="nk"> &lt;rusty&gt;</span> So, I'm voting to close the PR, apologize to llfourne and open a "backup blob" PR...
<a name="l-172"></a><span class="tm">21:00:12</span><span class="nk"> &lt;t-bast&gt;</span> the backup blob is quite simple to do ;)
<a name="l-173"></a><span class="tm">21:00:44</span><span class="nk"> &lt;cdecker&gt;</span> Hm, too bad, I really liked the proposal, it's a nice clean thing to do
<a name="l-174"></a><span class="tm">21:02:07</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">cdecker:</span> but the effect on implementations' key isolation is as disquieting as sending privkeys over the wire IMHO
<a name="l-175"></a><span class="tm">21:02:49</span><span class="nk"> &lt;cdecker&gt;</span> Ok, if the encrypted blob is also easy we can do that instead
<a name="l-176"></a><span class="tm">21:03:20</span><span class="nk"> &lt;ghost43_&gt;</span> isn't "backup blob" orthogonal to deterministic points? I mean regardless of storing a backup with the counterparty it would be highly useful to be able to scan the blockchain to find your channels and the counterparty in the first place
<a name="l-177"></a><span class="tm">21:03:59</span><span class="nk"> &lt;t-bast&gt;</span> you can just wait for nodes to reconnect to you
<a name="l-178"></a><span class="tm">21:04:01</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">ghost43_:</span> electrum allows that iirc rn by using an OP_RETURN
<a name="l-179"></a><span class="tm">21:04:26</span><span class="nk"> &lt;ghost43_&gt;</span> yes I am very familiar with what electrum does, I contrbute to it :P
<a name="l-180"></a><span class="tm">21:04:34</span><span class="nk"> &lt;ghost43_&gt;</span> it would save the OP_RETURN, that's all
<a name="l-181"></a><span class="tm">21:04:38</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">ghost43_:</span> it would be, but it's also not entirely practical, doesn't cover all cases, and is harder to implement.
<a name="l-182"></a><span class="tm">21:04:39</span><span class="nk"> &lt;roasbeef&gt;</span> oh cool yeh wasn't sure if electrum peeps were here lol
<a name="l-183"></a><span class="tm">21:05:00</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">rusty:</span> rn lnd's SCB stuff has worked pretty well in practice, a node never forget ths information it needs to force close after getting a chan reest message
<a name="l-184"></a><span class="tm">21:05:03</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">ghost43_:</span> sure, but doing it by negotiating a derivation which each possible node you might talk to is a lot of addresses to send to an electrum server
<a name="l-185"></a><span class="tm">21:05:53</span><span class="nk"> &lt;ghost43_&gt;</span> <span class="hi">BlueMatt:</span> yes, that is true
<a name="l-186"></a><span class="tm">21:08:58</span><span class="nk"> &lt;rusty&gt;</span> So quickly: backup blob needs a feature bit, a new "hold my beer" msg which updates the blob, and a new tlv field for init (or a new msg?) to return it.
<a name="l-187"></a><span class="tm">21:09:43</span><span class="nk"> &lt;t-bast&gt;</span> if you want to really store your very latest channel state, you need to add this blob to more messages
<a name="l-188"></a><span class="tm">21:09:51</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">rusty:</span> hold-by-beer ack
<a name="l-189"></a><span class="tm">21:09:58</span><span class="nk"> &lt;cdecker&gt;</span> Nice, having to fit into the TLV also puts a nice upper bound on size
<a name="l-190"></a><span class="tm">21:10:03</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">rusty:</span> something something tacked onto chan reest? (the blob)
<a name="l-191"></a><span class="tm">21:10:19</span><span class="nk"> &lt;roasbeef&gt;</span> the blob is meant just for force closing right? and not resumption?
<a name="l-192"></a><span class="tm">21:10:21</span><span class="nk"> &lt;ghost43_&gt;</span> <span class="hi">roasbeef:</span> depends if you want a per-chan blob
<a name="l-193"></a><span class="tm">21:10:30</span><span class="nk"> &lt;roasbeef&gt;</span> how would you handle a peer giving you a dated blob?
<a name="l-194"></a><span class="tm">21:10:43</span><span class="nk"> &lt;roasbeef&gt;</span> if it's per channel state...seems not possible
<a name="l-195"></a><span class="tm">21:11:01</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">roasbeef:</span> you gather them from all peers and take latest, I think.
<a name="l-196"></a><span class="tm">21:11:04</span><span class="nk"> &lt;t-bast&gt;</span> if you want it for resumption you need to add it to `commit_sig` and `revoke_and_ack`
<a name="l-197"></a><span class="tm">21:11:57</span><span class="nk"> &lt;roasbeef&gt;</span> gotta be static imo, no pitfalls, just ability to get the other side to force close if needed, so you'd store them w/ peer you don't have a channel w/
<a name="l-198"></a><span class="tm">21:12:09</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">t-bast:</span> ecliar does per state rn? so then users just trust it won't get swapped out/
<a name="l-199"></a><span class="tm">21:12:12</span><span class="nk"> &lt;roasbeef&gt;</span> ?
<a name="l-200"></a><span class="tm">21:12:16</span><span class="nk"> &lt;ariard&gt;</span> by resumption you mean per-revoked output punishment state?
<a name="l-201"></a><span class="tm">21:13:23</span><span class="nk"> &lt;t-bast&gt;</span> that's true, otherwise it does consume a lot of bandwidth/storage on many nodes, maybe a lighter backup makes more sense for a fully distributed solution (and just target unblocking force-close scenarios)
<a name="l-202"></a><span class="tm">21:13:50</span><span class="nk"> &lt;ghost43_&gt;</span> sending an old blob has similar game theory to the chan reestablish message dataloss protect I think
<a name="l-203"></a><span class="tm">21:13:51</span><span class="nk"> &lt;t-bast&gt;</span> but the mechanism should be opaque enough so that it can be re-used for full-state storage for nodes that want it imo
<a name="l-204"></a><span class="tm">21:14:01</span><span class="nk"> &lt;rusty&gt;</span> Well, you can pack whatever you want in there.  At least the info about what other channels you have, and any seed info associated.
<a name="l-205"></a><span class="tm">21:14:31</span><span class="nk"> &lt;t-bast&gt;</span> Perfect, as long as the spec just specifies it as a blob of bytes in a TLV that may be added to various messages, it will be flexible enough
<a name="l-206"></a><span class="tm">21:14:33</span><span class="nk"> &lt;roasbeef&gt;</span> <span class="hi">ghost43_:</span> imo no, this can let you give a peer an older version to braodcast, w/ chan reest you have deterrence of having a tower out there
<a name="l-207"></a><span class="tm">21:14:41</span><span class="nk"> &lt;t-bast&gt;</span> And it lets each implementation put whatever they'd like in there
<a name="l-208"></a><span class="tm">21:15:18</span><span class="nk"> &lt;t-bast&gt;</span> but you'd use your towers as well for that storage wouldn't you?
<a name="l-209"></a><span class="tm">21:16:13</span><span class="nk"> &lt;roasbeef&gt;</span> g2g will peep logs
<a name="l-210"></a><span class="tm">21:16:13</span><span class="nk"> &lt;ghost43_&gt;</span> <span class="hi">roasbeef:</span> kind of same situation with chan reest. if you lost the latest state but don't know it, the counterparty can trick you to force-close with it
<a name="l-211"></a><span class="tm">21:16:28</span><span class="nk"> &lt;rusty&gt;</span> I think embedding in init or as a separate post-init msg means you don't need a live channel to use it, so you can pay non-peers in future to do the same thing for you.
<a name="l-212"></a><span class="tm">21:16:51</span><span class="nk"> &lt;rusty&gt;</span> Anyway, let's move on, I have a hard stop in 15 too...
<a name="l-213"></a><span class="tm">21:16:54</span><span class="nk"> &lt;t-bast&gt;</span> Good idea
<a name="l-214"></a><span class="tm">21:17:06</span><span class="nk"> &lt;t-bast&gt;</span> Yep let's save splicing for next time and quickly discuss https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-April/003002.html
<a name="l-215"></a><span class="tm">21:17:12</span><span class="nk"> &lt;ariard&gt;</span> +1 to keep it in a post-init msg, bolt13 tower proposal has its own compensation mechanism
<a name="l-216"></a><span class="tm">21:17:13</span><span class="nk"> &lt;t-bast&gt;</span> It shuold just take a couple minutes
<a name="l-217"></a><span class="tm">21:17:35</span><span class="nk"> &lt;t-bast&gt;</span> <span class="cmd">#action </span><span class="cmdline">drop deterministic points in favor of an encrypted backup construction</span>
<a name="l-218"></a><span class="tm">21:17:36</span><span class="nk"> &lt;ariard&gt;</span> okay quickly i'm setting a bunch of irc workshop about better l2 onchain support
<a name="l-219"></a><span class="tm">21:17:43</span><span class="nk"> &lt;t-bast&gt;</span> <span class="topic">#topic </span><span class="topicline">ariard cross-layer work</span>
<a name="l-220"></a><span class="tm">21:17:51</span><span class="nk"> &lt;t-bast&gt;</span> <span class="cmd">#link </span><span class="cmdline">https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-April/003002.html</span>
<a name="l-221"></a><span class="tm">21:18:09</span><span class="nk"> &lt;t-bast&gt;</span> Let's just all attend if we can, it's going to be great :)
<a name="l-222"></a><span class="tm">21:18:27</span><span class="nk"> &lt;ariard&gt;</span> agenda is : package-relay or logically equivalent, full-rbf, coordinated security disclosure across layers, and onchain security tooling (e.g libstandardness)
<a name="l-223"></a><span class="tm">21:18:40</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">roasbeef:</span> can you poke bitconner to respond on https://github.com/lightningnetwork/lightning-rfc/pull/608#issuecomment-815496095 ? I'm vaguely leaning towards proposing we revert it over bothering to implement it.
<a name="l-224"></a><span class="tm">21:18:54</span><span class="nk"> &lt;ariard&gt;</span> if you have any other issues you wanna talk let me know but would like to keep it straigth, like 2-3 irc meetings
<a name="l-225"></a><span class="tm">21:18:56</span><span class="nk"> &lt;BlueMatt&gt;</span> yes, thanks for organizing ariard!
<a name="l-226"></a><span class="tm">21:19:18</span><span class="nk"> &lt;rusty&gt;</span> <span class="hi">ariard:</span> good initiative...
<a name="l-227"></a><span class="tm">21:19:22</span><span class="nk"> &lt;BlueMatt&gt;</span> what about pinning mitigations, eg the carve-out thinggy that anchors uses?
<a name="l-228"></a><span class="tm">21:19:30</span><span class="nk"> &lt;ariard&gt;</span> and schedule is mid-june, after bitcoin 2021
<a name="l-229"></a><span class="tm">21:19:58</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">BlueMatt:</span> i hope we can get ride of most pinning with package-relay/full-rbf but do u think something more specific here?
<a name="l-230"></a><span class="tm">21:20:41</span><span class="nk"> &lt;ariard&gt;</span> in fact you might deprecate carve-out and use only one anchor ouput if we have something like rbf-package relay
<a name="l-231"></a><span class="tm">21:21:02</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">ariard:</span> well, at the risk of getting into it pre-meeting here, I dont think full-rbf buys you anything when you still have to meet min-additional-relay fees, but also the carve-out was cause of package size limits, not package relay
<a name="l-232"></a><span class="tm">21:21:14</span><span class="nk"> &lt;BlueMatt&gt;</span> but, anyway, we should discuss it at your meeting!
<a name="l-233"></a><span class="tm">21:21:52</span><span class="nk"> &lt;t-bast&gt;</span> It's going to be interesting and a good opportunity to dive into a few rabbit holes
<a name="l-234"></a><span class="tm">21:22:02</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">BlueMatt:</span> to meet min-additional-relay fees you attach a cpfp and propagate as package? yeah for sure let's talk about it latter :)
<a name="l-235"></a><span class="tm">21:22:56</span><span class="nk"> &lt;BlueMatt&gt;</span> <span class="hi">ariard:</span> also package limits, but, yes, ok :)
<a name="l-236"></a><span class="tm">21:23:18</span><span class="nk"> &lt;cdecker&gt;</span> Definitely an interesting space I don't know much about, looking forward to the discussions ^^
<a name="l-237"></a><span class="tm">21:23:42</span><span class="nk"> &lt;cdecker&gt;</span> Anyway, got to go pretty soon
<a name="l-238"></a><span class="tm">21:24:02</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">BlueMatt:</span> i see package limits we might be willingly to bump them for op_ctv-style congestion tree, that kind of more advanced protocols
<a name="l-239"></a><span class="tm">21:24:18</span><span class="nk"> &lt;t-bast&gt;</span> Same for me, I'll have to drop off soon
<a name="l-240"></a><span class="tm">21:24:27</span><span class="nk"> &lt;t-bast&gt;</span> Thanks for your time everyone!
<a name="l-241"></a><span class="tm">21:24:33</span><span class="nk"> &lt;t-bast&gt;</span> <span class="cmd">#stopmeeting</span><span class="cmdline"></span>
<a name="l-242"></a><span class="tm">21:24:39</span><span class="nk"> &lt;ariard&gt;</span> <span class="hi">t-bast:</span> thanks for chairing!
<a name="l-243"></a><span class="tm">21:24:41</span><span class="nk"> &lt;t-bast&gt;</span> <span class="cmd">#endmeeting</span><span class="cmdline"></span></pre>
</body></html>
