20:04:59 <valwal> #startmeeting meeting-name
20:04:59 <lndev-bot> Meeting started Mon Aug 16 20:04:59 2021 UTC and is due to finish in 60 minutes.  The chair is valwal. Information about MeetBot at http://wiki.debian.org/MeetBot.
20:04:59 <lndev-bot> Useful Commands: #action #agreed #help #info #idea #link #topic #startvote.
20:04:59 <lndev-bot> The meeting name has been set to 'meeting_name'
20:05:13 <valwal> #topic warnings
20:05:33 <ariard> t-bast: yeah and i've discussed with other coredev orgas and they're okay to distribute more LN-invits :)
20:05:43 <BlueMatt> valwal: you gots to startmeeting
20:05:43 <BlueMatt> with the #s
20:05:54 <niftynei> she did! lol
20:06:02 <niftynei> i think we're on topic "warnings"
20:06:15 <BlueMatt> I left a number of comments on the pr
20:06:21 <BlueMatt> so waiting on those to be responded to
20:06:32 <BlueMatt> t-bast: commented as well, and i think we agreed on some proposed changes
20:06:32 <t-bast> Sounds like rusty needs to rebase and address comments
20:06:35 <BlueMatt> further, the pr needs to be rebased
20:06:40 <t-bast> But generally it's a concept ACK, right?
20:06:44 <BlueMatt> so i think its basically a "waiting on rusty to respond" thing
20:06:55 <valwal> ok
20:07:04 <valwal> #topic channel_type s
20:07:12 * rusty wakes up
20:07:27 <valwal> oh hey rusty!
20:07:33 <t-bast> hey rusty!
20:07:49 <BlueMatt> yea, def concept ack here, iirc lnd even has a pr to implement it
20:08:07 <rusty> OK, I will respond on PR.  I basically plastered advice over everywhere we said you MUST erorr, wherever it was theoretically psosible to recover, said you MAY send warning.
20:08:25 <rusty> (You can still send error!  And if you've closed, of course you should)
20:08:43 <BlueMatt> yea, the LDK implementation of the warnings message stuff that I pr'd largely ignored half of the error -> warning changes, since I'm not a fan of them and needs discussion on the pr :)
20:08:55 <niftynei> is it correct to say that "error -> close channel"/ "warning -> disconnect" or is that too broad a generalization
20:09:16 <BlueMatt> niftynei: no, you shouldnt even disconnect on warning
20:09:23 <t-bast> niftynei: usually it's even better to send a warning without disconnecting
20:09:42 <t-bast> niftynei: to avoid reconnect loops where your peer resends the same problematic message
20:09:49 <roasbeef> guess depends on what bleeds over to this new message, imo we should just have a new one that replaces all usage of the prior error message w/ richer context
20:09:49 <rusty> niftynei: error is "I have closed the channel, you should too", basically.
20:10:22 <roasbeef> most valuable error I've seen in the wild so far is the error when you get an invalid sig, have used that to find a bunch of state machine divergences within lnd, and most recently that HTLC ordering issue
20:10:40 <niftynei> the dual-funding impl in c-lightning uses warnings pretty much entirely; it fails the connection also tho as a sign to restart the negotiation. but that's maybe a niche case
20:10:54 <t-bast> roasbeef: true, that's the error that helped figure out many real bugs in the wild
20:11:10 <BlueMatt> roasbeef: that seems like a wholly separate discussion
20:11:25 <BlueMatt> roasbeef: the current warning pr is all about "how to tell the counterparty that you're *not* closing the channel but something happened
20:11:29 <rusty> BlueMatt: true, but it'd be a nice discussion to have.  Fortunately both warning and error are extensible.
20:11:32 <t-bast> niftynei: gotcha, disconnecting makes sense in that case, it's probably a case-by-case basis whether you should disconnect after sending a warning or not
20:11:36 <BlueMatt> roasbeef: if you want rich errors or whatever, we can do that in a new message.
20:11:43 <BlueMatt> or extending error/warning, as rusty notes
20:11:48 <niftynei> since "establishing a channel" you can safely restart the negotiation etc, yeah ok seems like a niche rather than a broad rule
20:12:37 <BlueMatt> rusty: indeed, its maybe a good thing to do, but I do feel like it needs at least a strawman proposal before we have a live discussion, otherwise we go in circles forever :)
20:12:43 <roasbeef> how useful will this warning message be if there's no new strucutred information? means we just all need to string match again...
20:13:00 <roasbeef> there's an ML thread where carla and rusty have started to work out a more structutred approach, I thought that was meant to be a part of this?
20:13:02 <BlueMatt> roasbeef: it allows you to implement error messages properly again :p
20:13:03 <t-bast> roasbeef: it's really useful in closing negotiation for example
20:13:16 <BlueMatt> ie, actually close the channel
20:13:21 <t-bast> roasbeef: and when using channel_type to open a new channel with a non-default type
20:13:28 <ariard> niftynei: afaict your usage of the warnings in the dual-funding context to rollback your negotiation matches the richer error context intent of roasbeef?
20:13:29 <roasbeef> t-bast: yeh I can see that being the case, but will it be if ppl send diff error strings vs having structured records? (using TLV)
20:13:49 <BlueMatt> roasbeef: yep, we can extend these messages with tlvs when there's a spec for it :)
20:13:52 <roasbeef> and the chan_type case is one that can be programtically handled most of the time
20:13:57 <t-bast> roasbeef: I agree it's still just a string that the node operator needs to understand, but it's a good thing to start with!
20:14:04 <rusty> roasbeef: nah, this predates that, it's old...
20:14:07 <BlueMatt> in the mean time, just *adding* the warning message is nice, cause we can use it in places where we dont want to close the channel but want to notify an error
20:14:26 <BlueMatt> cause its actually nice that we have the error messages which close channels imo
20:14:31 <BlueMatt> or notify counterparties we've closed
20:14:35 <roasbeef> if there's no new structured data, then how's this imrpove on the other error at all?
20:14:44 <roasbeef> given you can also use that to send out message, and most impls don't auto force close on it anymore
20:14:52 <t-bast> I agree with BlueMatt, it's already helpful in practice so let's roll it out, and improve later by adding more structure as we discover what we often need
20:14:56 <ariard> roasbeef: not force-closing the chan
20:15:16 <BlueMatt> roasbeef: yep, so we should *start* force closing on errors again :)
20:15:19 <ariard> which we already do quite liberally in LDK
20:15:23 <BlueMatt> cause, like, that's what the spec does
20:15:37 <roasbeef> that was always a dubious requirement imo
20:15:40 <BlueMatt> roasbeef: if you feel strongly, I suppose we could change the *current* error message message type to "warning" and add a new error message :)
20:15:50 <BlueMatt> roasbeef: its more "I've closed the channel, you should too, cause its gone"
20:15:52 <roasbeef> caused a lot of force closes early on when ppl disgareed on fees
20:16:28 <roasbeef> BlueMatt: yeh carla is working on that, there's a thread on the ML tracking the latest discussion (either new message or just extend prior w/ TLV data to be parsed)
20:16:38 <BlueMatt> roasbeef: no again thats separate
20:16:48 <BlueMatt> adding a tlv to indicate a type is something we can do *on top*
20:17:07 <niftynei> ariard: not exactly, it's still "string messages that need to be parsed", but you could definitely codify the errors via a TLV in the warnings!
20:17:34 <BlueMatt> roasbeef: do you have a specific suggestion for the warning message prs aside from "I dont care about this"?
20:17:43 <BlueMatt> because otherwise I think we can just go forward with it
20:17:45 <roasbeef> BlueMatt: agree we can do on top, but don't see what just another error message delivers
20:17:56 <niftynei> there's probably a nice set of error states in the open to encode too, channel-type being one of them
20:18:05 <ariard> niftynei: gotcha, it's still seems a in-the-middle solution where you're parsing human-readable destinaed output to have machine-level automatic reactions
20:18:12 <BlueMatt> roasbeef: other people here seem to think its valuable to be able to communicate that a channel is closed. I tend to agree
20:18:28 <roasbeef> niftynei: yeh see this mail: https://lists.linuxfoundation.org/pipermail/lightning-dev/2021-July/003142.html
20:18:34 <BlueMatt> roasbeef: if you dont, that's ok, we can still do it and you can just log that the channel is closed and make your users do more work.
20:18:39 <niftynei> like that's (channel opens) are probably the highest value place to add codified errors
20:18:46 <roasbeef> why can't the erorr be used for that? particularluy if the channel is closed, then the chan_id isn't really a thing anymore
20:19:05 <BlueMatt> roasbeef: it can be, it can be added on top if it!
20:19:19 <BlueMatt> because that error (a) requires more discussion, (b) isn't broadly implemented, (c) isnt even a spec pr
20:19:29 <roasbeef> so then the same meessage can just be used and we don't need a new one...?
20:19:35 <BlueMatt> "i want to delay to add more stuff" is generally not a valid objection unless "more stuff" is quick and easy :)
20:19:46 <BlueMatt> roasbeef: yes, you can always add tlvs at the end of any message
20:19:48 <BlueMatt> to provide more context
20:19:48 <niftynei> well, you definitely have errors in the open that are distinct from warnings
20:20:03 <roasbeef> rather than delay, I don't see the motivation here given error already exists, and this is just that w/ a diff type
20:20:04 <ariard> roasbeef: yeah i think that's matt proposal to merge the future carla's richer-context-error proposal in the warning message thanks to TLV
20:20:26 <niftynei> e.g. once the channel commitments have been exchanged, you error to signal you're going to chain
20:20:46 <BlueMatt> you want more context in errors/warnings, great! lets add warnings and then we can slap the tlv on the end! everyone gets what they want and y'all dont hold up progress for perfection :)
20:21:01 <t-bast> TBH the current state sounds really simple to me: errors and warnings are two different things (should be obvious), it's good to have both, currently it's just an unstructured string, later we can add structure in tlv to automate reactions. That's it!
20:21:01 <niftynei> if you're RBF'ing an extant open attempt, you still want warnings to signal you're failing the re-negotiation, not closing the channel
20:21:31 <roasbeef> as is, the warning says it should be text based again, so you can't add a TLV there
20:21:45 <roasbeef> since it inherits the ascii req afaict
20:21:47 <BlueMatt> yes you can
20:21:52 <BlueMatt> its length-delimited
20:21:56 <t-bast> as all lightning messages it has a trailing tlv stream
20:22:00 <BlueMatt> you can trivially add anything to the message end
20:22:16 <roasbeef> t-bast: as I've always said, traliling tlv infront of var sized field doesn't really work imo
20:22:20 <BlueMatt> #action rusty to rebase and respond to comments on warning
20:22:23 <BlueMatt> next topic
20:22:27 <roasbeef> since you can run out of space there
20:22:34 <BlueMatt> you can run out of space in any message
20:22:36 <BlueMatt> come on man
20:22:36 <valwal> #topic channel_type negotiation
20:22:37 <BlueMatt> lets move on
20:22:56 <valwal> we can circle back if we finish everything else (lol)
20:23:01 <roasbeef> BlueMatt: no...open channel as is doesn't have var sized fields as an example
20:23:41 <t-bast> roasbeef: just send an empty string when you want to put tlvs then, there's nothing complicated here...please le'ts move to other topics, feel free to comment on the PR to elaborate?
20:23:52 <BlueMatt> where are we on channel_type negotiation, are you happier with where it went, roasbeef?
20:24:18 <t-bast> I've got channel_type ready in eclair, and found a few issues when testing compatibility with c-lightning
20:24:24 <roasbeef> t-bast: I think should be continued in that ML thread, will reply there, as there's till more to explore there and even just motivation for adding a new message that's exactly the same as another one w/ no added benefit
20:24:33 <t-bast> rusty did you have time to check my comments on your c-lightning PR?
20:24:35 <roasbeef> we have an impl of chan type now, need to do interop testing
20:24:50 <roasbeef> t-bast: anything you ran into that you think may bleed over to othe rimpls?
20:25:11 <t-bast> roasbeef: it really looks like simple bugs in the implementation, nothing spec-related AFAICT
20:25:24 <t-bast> roasbeef: if you have an lnd branch to share I can test it against eclair tomorrow!
20:25:25 <rusty> t-bast: sorry, will have to rebase and get back to this.
20:25:47 <roasbeef> t-bast: it's here: https://github.com/lightningnetwork/lnd/pull/5373
20:26:11 <t-bast> rusty: no worries, just ping me when it's ready and I'll run my test scripts
20:26:21 <t-bast> roasbeef: cool thanks, I'll test it
20:26:33 <BlueMatt> cool
20:26:39 <BlueMatt> #action t-bast and roasbeef to do cross-impl testing
20:26:41 <BlueMatt> next topic?
20:26:43 <roasbeef> the PR let us simplify our integration tests a good bit too, since we can just add the type vs the build tag, etc, etc
20:26:51 <valwal> #topic Updated closing_signed fee requirements #847
20:26:54 <BlueMatt> even nicer, roasbeef!
20:26:55 <roasbeef> who's driving the bot rn? isn't it tied to a single person?
20:27:08 <BlueMatt> roasbeef: valwal is, but i thought anyone could action?
20:27:14 <roasbeef> ah maybe, idk
20:27:18 <gene> hi
20:27:19 <roasbeef> guess we'll find out at the end kek
20:27:29 <cdecker[m]> Valwal is chairing
20:27:38 <BlueMatt> it seems there's rough agreement on 847, at least no objections on the pr
20:27:48 <BlueMatt> t-bast: and I need to do cross-impl testing, I think, and then it can land?
20:27:51 <BlueMatt> any objections?
20:28:01 <BlueMatt> and/or with c-lightning folks, who've also mayne implemented it?
20:28:23 <t-bast> I'd love to land this one!
20:28:38 <roasbeef> t-bast: do you expose the knob to users (picking a chan type in the open chan API)? and if so, is it a type or do you let them flip each of teh bits? just curious from an API perspective as that came up in ours during review
20:28:42 <BlueMatt> there's also a number of dust concerns related to closing-transactions exposed today, looks like everyone except eclair currently allows nodes to set a dust limit which causes closing tx to be unspendable
20:29:02 <BlueMatt> but i think that needs a larger closing_signed change
20:29:06 <BlueMatt> so would propose it happen in a new pr
20:29:15 <t-bast> roasbeef: yes, I've defined a string enum of channel_types that the user can chose in the `open` API, and then we communicate back whether it was rejected by the other side or not
20:29:31 <roasbeef> BlueMatt: why would it cause to to be unspendable? assuming impls to verification that rejects bad dust values that is
20:29:54 <BlueMatt> roasbeef: well right now lnd doesn't (as far as I can tell) verify the counterparty-set dust limit at all, despite the spec saying you must :p
20:29:55 <ariard> BlueMatt: i think we allow p2pkh/p2sh closing outputs on the ldk side, our max dust_limit_satoshis is 660
20:29:57 <roasbeef> or I guess unbroadcastable? q still stands
20:29:58 <ariard> sats
20:29:59 <BlueMatt> roasbeef: but, more broadly, read your email!
20:30:05 <t-bast> BlueMatt: ACK on fixing these dust issues in a separate PR, to allow #847 to land sooner
20:30:15 <roasbeef> it does, but it can be improved ;)
20:30:32 <t-bast> ariard: the issue is not your max dust_limit but rather your min
20:30:33 <roasbeef> yeh dust is a can of worms
20:30:44 <BlueMatt> roasbeef: can you point to where? The only thing I found looking for it was checking an upper-bound, not a lower-bound, and eugene appeared to confirm that was the case.
20:30:48 <t-bast> roasbeef: yes, it's just unbroadcastable
20:30:48 <ariard> t-bast: yeah let's fix dust separate from 846
20:30:52 <ariard> *847
20:31:03 <rusty> Yes, ack 847.
20:31:29 <BlueMatt> ok, so no objections to (a) cross-impl testing then merging 847, (b) fixing dust in closing transactions in a new pr.
20:31:31 <BlueMatt> next topic?
20:31:34 <t-bast> rusty: BTW on #847 my latest tests against c-lightning were green, nothing weird came out
20:31:42 <t-bast> BlueMatt: ACK
20:31:44 <Crypt-iq> so coop closing doesn't take into account output type dust limits roasbeef
20:31:44 <rusty> t-bast: thans!
20:31:53 <valwal> #topic BLIPs
20:31:54 <BlueMatt> t-bast: have y'all done cross-imppl testing? I think in that case we can land now?
20:31:56 <Crypt-iq> ie spending to a p2pkh < 546, p2sh < 540
20:32:16 <ryanthegentry> so on bLIPs first ty BlueMatt, ariard, t-bast for the comments
20:32:24 <ariard> t-bast: does the spec mandates to enforce dust_limit_satoshis at coop closing?
20:32:27 <ryanthegentry> Helped a lot with reframing the proposal here around feature bits, message types and TLVs assignments rather than be so generic
20:32:48 <t-bast> BlueMatt: I've successfully tested against c-lightning - if that means we can land it now (or whenever rusty confirms that they're ready) I'm all for it ;)
20:32:52 <t-bast> ariard: I think so, yes
20:32:54 <BlueMatt> I think the Real (tm) question about bLIPs is "what is allowed to be a bLIP, and what MUST go in the BOLTs"
20:32:58 <rusty> t-bast: yep, ack!
20:33:00 <BlueMatt> t-bast: land it! (imo)
20:33:07 <BlueMatt> 🎉
20:33:08 <ariard> t-bast: we do on the LDK-side, like enforcing the holder-side but not checking the counterparty, that's really confusing i admit
20:33:15 <roasbeef> answer to #1 is basically anything imo
20:33:32 <roasbeef> #2 is the grey area, prob something that everyone must to do have a working network, like same htlc format
20:33:54 <ryanthegentry> BlueMatt: one thing that seems low-hanging fruit is Message Types "32768-65535 are set aside for experimental and application-specific messages" per BOLT #1
20:34:04 <ryanthegentry> but nothing similar exists for feature bits or TLVs
20:34:08 <ariard> yeah we could still host best practices in the bolt as long as it's not mandatory
20:34:29 <ryanthegentry> could have a suggested sandbox area for all three, and encourage experimenters to document + ask for review in bLIPs
20:34:33 <t-bast> ariard: good point, I thought it made sense to check all txs so it seemed obvious to also do it for the closing tx, but in fact it's debatable...worth clarifying!
20:34:40 <ariard> the ietf do this with a lot of documents, for e.g dnssec best practices : https://www.rfc-editor.org/rfc/rfc6781.html
20:34:42 <t-bast> #action t-bast to clarify dust limits in closing txs
20:34:43 <roasbeef> ryanthegentry: what's all 3 here?
20:34:50 <BlueMatt> I dunno, I feel like if you're just doing random testing, it doesnt need to be a bLIP - it should be constrained to your impl cause its "random testing"
20:34:54 <ryanthegentry> Feature Bits, Message Types, TLVs
20:34:56 <roasbeef> ariard: yeh could have a lot of stuff like that re fee bumping, etc
20:35:02 <BlueMatt> if its something you want to include in eg the state machine, it should be a bolt?
20:35:25 <cdecker[m]> Definitely
20:35:32 <ariard> ryanthegentry: my point was about for the bolt process to formalize first the namespace attribution
20:35:38 <BlueMatt> tho i guess maybe one example is rusty's turn-based-htlc thing, like, maybe thats only done in c-lightning but still others could implement it so could be a bLIP? I dunno, its all grey areas
20:35:43 <ariard> to let blip devs reused without any conflicts
20:35:48 <roasbeef> BlueMatt: yeh sure, re random testing, someone could modify the state machine tho, and add say DLC related stuff, imo that's bLIP territory since eveyrone doens't need to do it as it suger on top of everything else
20:36:02 <ariard> like message types/tlvs types
20:36:16 <BlueMatt> roasbeef: right, def dont want DLC in BOLTs (tho arguably not even in bLIPs either, but maybe just enough to claim message ids or whatever)
20:36:19 <roasbeef> ariard: agree they meet re namespacing claims to prevent collisions, etc
20:36:32 <ryanthegentry> ariard: understood
20:36:44 <cdecker[m]> The round based protocol should be a bolt imho
20:36:51 <ariard> BlueMatt: i can say the DLC process is working quite nicely and we would prefer to stay on our own though referrencing blips if they're good :)
20:37:00 <BlueMatt> cdecker[m]: but what if no one but c-lightning ever implements it?
20:37:09 <rusty> IMHO: best practices, pre-widespread testing, weird ideas are all great as BLiPS.  Some may become BOLTs, sure...
20:37:15 <BlueMatt> cdecker[m]: we cant get consensus on it in a bolt, should it still be written up as a bLIP?
20:37:21 <roasbeef> cdecker[m]: could be, one benefit ofr the bLIP style is that it'll be a contained document to provide additional context, etc, etc -- vs being an if statement in a much larger doc
20:37:21 <rusty> I think ppl find BOLTs intimidating.
20:37:28 <cdecker[m]> It still touches the state machine and is negotiated during setup
20:37:34 <ryanthegentry> rusty: sad that they do but agree
20:38:04 <t-bast> rusty: but they may find a huge collection of bLIP very intimidating as well...
20:38:07 <BlueMatt> maybe the criteria should be "who implements this"-based?
20:38:10 <ariard> rusty: yeah we might even run out of review bandwidth for best practices even if they're deepily bolt-oriented fee-bumping, timelocks settings
20:38:35 <BlueMatt> eg "if you seek broad implementation of this as a core part of lightning, it must be a bolt, if you do not, a bLIP"?
20:38:45 <BlueMatt> i mean its fuzzy but at least decent guidance?
20:38:53 <rusty> ariard: true, but if we have an easy entree into the spec, maybe long term we get more qualified reviewers ?
20:39:01 <roasbeef> ariard: yeh agreed re review bandwidth, there's just so much stuff given the wide design space of LN, something like schnorr integration is BOLT territory since we all need to do it and it already has braod buy in
20:39:12 <roasbeef> BlueMatt: I like something along those liens
20:39:19 <rusty> If everyone needs to implement it, it needs to be a BOLT?
20:39:30 <BlueMatt> rusty: define "needs"
20:39:37 <BlueMatt> i think it needs to be a bit broader than "needs"
20:39:44 <ariard> rusty: yeah i'm willingly to test the experiment though for any safety/operational best practices we're going to fetch the already-under-water same people
20:39:45 <rusty> BlueMatt: vagueness is sometimes a feature.
20:39:49 <BlueMatt> indeed
20:39:59 <ariard> like the risk of introducing security theater in a ref document
20:39:59 <BlueMatt> but I think "needs" isnt vague enough :p
20:40:31 <t-bast> "If it could benefit the whole network it should be a BOLT"?
20:40:35 <roasbeef> there's a lot of end-to-end behavior stuff that can be bLIP'd, given you just need the sender+receiver to understand it, like ppl adding podcast metadata to TLVs
20:40:56 <BlueMatt> but eg i think keysend *should* have been a bolt
20:40:58 <ariard> roasbeef: yeah and please think about the few L2s devs like darosior/me also keeping the pace with mempool changes to be sure the base layer doesn't break us :/
20:40:59 <roasbeef> also feasible something starts as a bLIP, then gets broad buy in and becomes "prompted" somehow
20:41:05 <BlueMatt> so it cant just be "if its end-to-end, bLIP"
20:41:33 <roasbeef> BlueMatt: maybe the case, the history of keysend is that it started out as a small thing devs were into within the context of lnd (didn't even have a feature bit), then grew beyond that
20:41:46 <BlueMatt> yes, I'm aware, not criticizing
20:41:53 <michaelfolkson> Any chance of just using BOLT 100+ for what would be bLIPs and avoiding months/years of discussions on what should be a bLIP and what should be a BOLT? Or has that ship sailed?
20:41:57 <ariard> BlueMatt: i disagree here and i think keysend is good enough as a blip
20:41:59 <BlueMatt> just using it as an example of something that I think we'd want to fit into the "this should be a bolt"
20:42:11 <BlueMatt> michaelfolkson: it has nothing to do with the numbers
20:42:12 <ariard> like not risk of channel-closure if you fucked up a keysend implem
20:42:12 <roasbeef> so bLIPs can be an incubation space of sorts for new things before the get more widely adopted
20:42:13 <t-bast> michaelfolkson: I think that's orthogonal
20:42:25 <niftynei> is adding this grey area better than not having a grey area? e.g. is having a set of documents that aren't BOLTS worthwhile if it introduces more surface area for debate?
20:42:33 <BlueMatt> ariard: i dunno, users expect it to work broadly, there's a lot of real UX issues caused by keysend not being universal
20:42:43 <BlueMatt> so i think it *def* fits under "this really needs to be universal"
20:42:49 <roasbeef> even w/ keysend at the time, some ppl wanted to do it a diff way, iirc using the shared secret of the onion instead, view diverged and keysend was just implemented as is in lnd
20:42:55 <ariard> BlueMatt: sure but solving the UXissuess that's done with a spec document, be it blip or bolt :)
20:43:03 <BlueMatt> ariard: its solved by things being universal
20:43:09 <niftynei> i think i just said the same thing as michaelfolkson
20:43:10 <BlueMatt> which I think is *precisely* the difference between blip and bolt
20:43:12 <niftynei> :P
20:43:20 <ariard> BlueMatt: right and things can become universal by either blip, bolt or bip
20:43:31 <roasbeef> niftynei: does it introduce more surface area? imo BOLT is prespriptive (you gotta do this), bLIP is descriptive (here's how thing things works and what we use it for)
20:43:33 <ariard> that's a communication-towards-devs issue
20:43:41 <michaelfolkson> This discussion will run and run. There will always be grey area with between BOLT and bLIPs. I just find this the least interesting thing to discuss with minimal payoff (but maybe that's just me)
20:43:47 <BlueMatt> ariard: if they are universal, they can/should migrate from blip to bolt (which is fine!) but if its intended to be, or is universal, it should be a bolt, not remain a blip
20:44:01 <roasbeef> michaelfolkson: it's progressing pretty well in the spec PR...
20:44:18 <ryanthegentry> I really like the concreteness of looking at how valwal adjusted BOLT #9 in her Keysend bLIP
20:44:20 <ryanthegentry> https://github.com/lightningnetwork/lightning-rfc/blob/2ce13ef01a17de1ccefa615072b4bee8f13e4ca0/09-features.md
20:44:27 <t-bast> I think bLIPs can be useful because otherwise we're currently either using PRs-that-dont-get-reviewed or unspecified-things-in-implementations for it - at least having things documented centrally is an improvement
20:44:31 <ariard> BlueMatt: and what if in the future the dlcspec start to implement chan_type?
20:44:35 <ryanthegentry> with the "bLIP Reserved Feature Bits" and a link to the descriptive doc
20:44:37 <roasbeef> t-bast: +100
20:44:37 <BlueMatt> so, i guess, to make it concrete, if we put text in the blip 1 doc that says something like "if its intended to become universal or near universal, it must be a bolt", is that ok?
20:44:38 <ariard> should it also mo ved as a bolt
20:44:58 <BlueMatt> ariard: DLC is never intended to be universal? so it can reamian a blip
20:45:01 <roasbeef> BlueMatt: yeh something like that could work as a quick heuristic
20:45:11 <BlueMatt> dlc is a specific thing that some people will implement, but certainly isn't required
20:45:15 <ariard> BlueMatt: what do you mean exactly by "universal" ?
20:45:39 <BlueMatt> ariard: as in "all lightning nodes should implement this in order to keep reasonable compatibility between lightning nodes and clients"
20:45:45 <niftynei> roasbeef: i think you're using prescriptive in a way that i'd disagree with; ideally any spec is descriptive (procedural)
20:45:54 <ariard> BlueMatt: i think in previous discussions we had the idea that a blip could be promoted to a bolt it's widely adopted by LN implems
20:46:04 <roasbeef> it's kinda an emergent trait imo, keysend wasn't really in that bucket a year ago, but it's more universal these days as devs view it as a sort of standard feature an impl should have
20:46:24 <BlueMatt> ariard: yes, if something starts as "we're doing this, and dont really expect others to" and then others do it, users start expecting it, and it becomes something that everyone does/has to do, then it can migrate
20:46:25 <ariard> BlueMatt: yeah but reality, is that LN universality is and will always be a moving target
20:46:26 <rusty> michaelfolkson: true, but I think trying an area with a lower barrier to entry may encourage more participation.
20:46:31 <BlueMatt> ariard: i dont think anyone disagrees that migration is an option?
20:46:54 <BlueMatt> roasbeef: more importantly, i think, *users* expect it to be universal :p
20:47:11 <ariard> BlueMatt: so i think the migration path is solving both our concern
20:47:11 <roasbeef> niftynei: yeh I guess we differ there w.r.t definition, another take is bitcon consensus rules are prescriptive, policy is discriptive -- the set of things all LN implementation need to agree on is smaller in comparison, so there's a lot of free energy to be used for new ideas/concepts
20:47:25 <niftynei> what if we just let spec authors decide how to propose their stuff and see what happens
20:47:29 <BlueMatt> ok, so do we have consensus, niftynei what say you? are there other concerns you have?
20:47:43 <t-bast> ryanthegentry: on the contrary, I'm wary of bLIPs modifying directly bolts, because that will require more review from more people - I'd rather have bLIPs only update other bLIPs to avoid needing more review from people who already spend a lot of time reviewing stuff
20:47:48 <ariard> BlueMatt: note, i think we won't agree all on what should become universal and the really long-term direction of lighnining, it's an evolutionary process
20:47:51 <BlueMatt> niftynei: do you have specific objection to, or think its uneccessary, to specify things based on a "universal implementation" heuristic?
20:48:02 <BlueMatt> ariard: yes, of course, its vague, and we'll disagree, but at least its the heuristic.
20:48:10 <roasbeef> niftynei: that's teh case rn, now they have another option
20:48:29 <michaelfolkson> The thing with new acronyms and processes is they seem exciting, glitzy and solve the problems of previous acronym at the beginning. But then after a while they suffer from exact same challenges ;)
20:48:36 <ariard> roasbeef: and Core's policy is prescriptive for LN :/
20:48:36 <ryanthegentry> t-bast: touché :)
20:48:40 <roasbeef> one that's a bit more defined, and may be interpreted to carry less weight
20:48:57 <BlueMatt> michaelfolkson: I think everyone here agrees that blips solve a specific issue, and have been proposing similar ideas since before it had a time or felt exciting
20:49:14 <cdecker[m]> Well having things documented is definitely the right thing to do. When combined with a migration to bolt once it becomes central to LN also seems ok
20:49:29 <niftynei> i feel like we're trying to solve a problem that exists but isn't really the purview of this chat idk
20:49:36 * michaelfolkson goes back to lurking
20:49:43 <BlueMatt> niftynei: can you elaborate?
20:50:18 <ariard> michaelfolkson: that's quite true from xp, the dlcspecs was quite fast at first, then slows down considerably now you have multiple implems
20:50:58 <niftynei> more documentation of how things work is always a good thing, the scope of who else you expect/intend to also adopt them is a function of the level of interoperability you expect the application to have with others, no? and which application that is exactly
20:51:14 <ariard> i've a doubt on such "universal implementation" heuristic to solve issues with long-term economic consequences for the network, like channel jamming
20:51:19 <t-bast> ryanthegentry: maybe it's just my personal opinion, but I'd rather have a few common bLIPs that may get updated frequently (e.g. to list feature bits / message types / tlv fields used by all bLIPs) that don't really need to be looked at by all LN devs than updating BOLTs for that
20:51:30 <cdecker[m]> I guess the slowdown is the cost of maintaining compatibility and avoid a netsplit :-)
20:51:37 <ariard> the best approach might be just to let different solutions compete and see with time which one is the better
20:52:01 <ariard> cdecker[m]: note, a netsplit is a security concer for all of us as we all share the same mempool/blockspace :)
20:52:16 <roasbeef> ok, something something universal, ship it!
20:52:28 <BlueMatt> <ariard> i've a doubt on such "universal implementation" heuristic to solve issues with long-term economic consequences for the network, like channel jamming <-- huh?
20:52:33 <BlueMatt> I'm *really* confused by what this means
20:52:40 <niftynei> if you're working on a lightning node implementation and want it to talk to other lightning nodes then you'd want to look at the BOLTs, no?
20:52:47 <ariard> BlueMatt: i mean to survive any issue with economic or lot-of-context
20:52:47 <roasbeef> I think he means we'd want a network wide solution to stuff like that BlueMatt
20:52:47 <cdecker[m]> Yeah, was thinking more of incompatible end-to-end things that just get rejected
20:53:03 <BlueMatt> <niftynei> more documentation of how things work is always a good thing, the scope of who else you expect/intend to also adopt them is a function of the level of interoperability you expect the application to have with others, no? and which application that is exactly <-- I'm *really* confused if you're disagreeing with anything I'm saying or not.
20:53:06 <roasbeef> niftynei: yeh for the every base level of functionality, lots of added stuff you may not need to impl just to get a basic payment working
20:53:11 <ariard> roasbeef: yeah that
20:53:13 <roasbeef> the very base*